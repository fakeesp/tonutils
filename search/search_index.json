{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TON Cookbook","text":"<p>This documentation is under development and is not the final version. Content, structure, and examples may change significantly in upcoming updates.</p>"},{"location":"cookbook/cnft/","title":"Creating Compressed NFTs","text":""},{"location":"cookbook/cnft/#introduction","title":"Introduction","text":"<p>Compressed NFT (cNFT) is a specialized digital asset format that optimizes data storage. Data compression algorithms reduce file sizes while preserving each asset\u2019s uniqueness. This process saves server space and lowers data storage and transmission costs. In addition, Merkle trees minimize storage requirements and enhance the efficiency of cNFT collections.</p>"},{"location":"cookbook/cnft/#features","title":"Features","text":"<ul> <li>Resource savings: Merkle trees store only essential data, reducing gas costs and network load.  </li> <li>Improved scalability: Efficient contracts can handle large NFT volumes without performance loss.  </li> <li>Optimized data storage: Keeping minimal on-chain information boosts system responsiveness and saves space.  </li> <li>Enhanced security: Merkle trees enable fast data integrity checks and robust asset protection.  </li> <li>Cost reduction: Shift minting costs to end users and create \u201cvirtual\u201d on-chain items only when needed.</li> </ul>"},{"location":"cookbook/cnft/#compressed-nft-support","title":"Compressed NFT Support","text":"<p>Current limitations Most popular wallets and marketplaces do not display unclaimed cNFTs or NFTs from collections that are not official partners. For example, the Telegram wallet and the Getgems marketplace index only the first 200 items for unofficial collections, which poses challenges for larger collections.</p> <p>Attack scenario A malicious actor could create hundreds of thousands of NFTs at minimal cost, forcing marketplaces to store all related data\u2014even if the attacker does not host the items but generates them on demand.</p> <p>Potential solution Provide a dedicated interface where users can claim their cNFTs. Once claimed, NFTs are indexed and displayed in wallets and marketplaces as standard NFTs, ensuring better visibility and accessibility.</p>"},{"location":"cookbook/cnft/#setup-deployment","title":"Setup &amp; Deployment","text":""},{"location":"cookbook/cnft/#nft-preparation","title":"NFT preparation","text":"<p>Before deployment, you need to prepare the metadata and images for your NFTs.</p>"},{"location":"cookbook/cnft/#metadata-preparation","title":"Metadata preparation","text":"<ul> <li>Collection metadata   Create a <code>collection.json</code> file that includes the required fields as specified in the NFT token data standard. Example:</li> </ul> <pre><code>{\n    \"name\": \"&lt;collection name&gt;\",\n    \"description\": \"&lt;collection description&gt;\",\n    \"image\": \"&lt;link to the image (e.g. https://yourdomain.com/logo.png)&gt;\"\n}\n</code></pre> <ul> <li> <p>NFT item metadata     For each NFT, create a separate JSON file (e.g., <code>0.json</code>, <code>1.json</code>, etc.) with the required fields as specified in the NFT token data standard. Example:</p> <pre><code>{\n    \"name\": \"&lt;item name&gt;\",\n    \"description\": \"&lt;item description&gt;\",\n    \"image\": \"&lt;link to the image (e.g. https://yourdomain.com/0.png)&gt;\"\n}\n</code></pre> </li> </ul>"},{"location":"cookbook/cnft/#resource-preparation","title":"Resource preparation","text":"<ul> <li>Images: Prepare images for the collection (for example, <code>logo.png</code> for the avatar) and for each NFT (for example, <code>0.png</code>, <code>1.png</code>, etc.).</li> <li>JSON files: Host your <code>collection.json</code> and NFT JSON files on a publicly accessible server or repository. Ensure each file has a unique URL.</li> </ul> <p>Note</p> <p>All images and JSON files must be directly accessible via their URLs.</p>"},{"location":"cookbook/cnft/#tc-manifest-preparation","title":"TC Manifest preparation","text":"<p>Create a TON Connect manifest JSON file to describe your application during the wallet connection process. Example:</p> <pre><code>{\n  \"url\": \"&lt;app url&gt;\",\n  \"name\": \"&lt;app name&gt;\",\n  \"iconUrl\": \"&lt;app icon url&gt;\"\n}\n</code></pre> <p>Note</p> <p>Ensure that this file is publicly accessible via its URL.</p>"},{"location":"cookbook/cnft/#owner-list-preparation","title":"Owner List preparation","text":"<p>Prepare an <code>owners.txt</code> file that lists the addresses of NFT owners, one per line. The first address corresponds to item index <code>0</code>, the second to item index <code>1</code>, and so on. Example:</p> <pre><code>UQDYzZmfsrGzhObKJUw4gzdeIxEai3jAFbiGKGwxvxHinf4K\nUQCDrgGaI6gWK-qlyw69xWZosurGxrpRgIgSkVsgahUtxZR0\n</code></pre>"},{"location":"cookbook/cnft/#infrastructure-preparation","title":"Infrastructure preparation","text":"<p>Set up a server to host your API and the interface for claiming NFTs. Also, obtain a domain for accessing the API. In this example, a local test deployment is run on a home machine using ngrok to create a public URL.</p>"},{"location":"cookbook/cnft/#claiming-api-setup","title":"Claiming API Setup","text":"<ol> <li> <p>Clone the repository     Clone the project containing all necessary source files:</p> <p>```bash git clone https://github.com/nessshon/cnft-toolbox  ````</p> </li> <li> <p>Install dependencies     Install Docker, Docker Compose, and ngrok, and ensure they are properly configured on your machine.</p> </li> <li> <p>Create a Telegram bot     Create a Telegram bot and obtain its API token.</p> </li> <li> <p>Expose your API     Use ngrok to create a public URL for testing:</p> <pre><code>ngrok http 8080 \n</code></pre> <p>For production: Set up a custom domain and configure Nginx to proxy requests to your API on port 8080. This involves:</p> <ul> <li>Registering a domain and pointing it to your server.</li> <li>Configuring Nginx to proxy requests to your API on port 8080.</li> <li>Create a <code>.env</code> file Duplicate the <code>env.example</code> file to <code>.env</code> and update it with your specific configuration. The table below describes each key:</li> </ul> Key Description Example Notes <code>PORT</code> Port on which the API will run. <code>8080</code> <code>ADMIN_USERNAME</code> Admin username for accessing restricted functionalities. <code>admin</code> <code>ADMIN_PASSWORD</code> Admin password for accessing restricted functionalities. <code>password</code> <code>DEPTH</code> Depth for the NFT collection (max items = <code>2^DEPTH</code>; maximum DEPTH is 30). <code>20</code> <code>IS_TESTNET</code> Specify if you are connecting to the TON testnet (<code>true</code>) or mainnet (<code>false</code>). <code>true</code> or <code>false</code> <code>POSTGRES_PASSWORD</code> Password for PostgreSQL authentication. <code>secret</code> <code>POSTGRES_DB</code> Name of the PostgreSQL database. <code>merkleapi</code> <code>POSTGRES_URI</code> Full connection URI for PostgreSQL. <code>postgresql://postgres:secret@db:5432/merkleapi</code> <code>BOT_TOKEN</code> Token for your Telegram bot (from @BotFather). <code>123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11</code> Used for the NFT claiming interface. <code>API_BASE_URL</code> External domain of your API. <code>https://example.ngrok.io</code> Replace with your public URL (e.g., via ngrok). <code>TONCONNECT_MANIFEST_URL</code> URL for the TON Connect manifest file. <code>https://example.com/tonconnect-manifest.json</code> Replace with the public URL of your manifest file. <code>COLLECTION_ADDRESS</code> Address of the NFT collection. Fill this in after deploying the collection. </li> <li> <p>Start the API and database     Run the following command to start the API and database:</p> <pre><code>docker-compose up -d db api \n</code></pre> </li> <li> <p>Migrate the database     Create the required tables in the database:</p> <pre><code>docker-compose exec api /ctl migrate \n</code></pre> </li> <li> <p>Add owners     Place your <code>owners.txt</code> file (containing owner addresses) into the <code>api</code> folder, then run:</p> <pre><code>docker-compose exec api /ctl add /api/owners.txt \n</code></pre> </li> <li> <p>Rediscover items     In your browser, navigate to <code>&lt;API_URI&gt;/admin/rediscover</code> and log in using your <code>ADMIN_USERNAME</code> and <code>ADMIN_PASSWORD</code>. If successful, you will see <code>ok</code> in the browser. After a short time (depending on the number of items), a file (e.g., <code>1.json</code>) appears in the <code>api/apidata/upd</code> folder.</p> </li> <li> <p>Generate an update     Run the following command to generate an update:</p> <pre><code>docker-compose exec api /ctl genupd &lt;path-to-update-file&gt; &lt;collection-owner&gt; &lt;collection-meta&gt; &lt;item-meta-prefix&gt; &lt;royalty-base&gt; &lt;royalty-factor&gt; &lt;royalty-recipient&gt; &lt;api-uri-including-v1&gt; \n</code></pre> <p>Replace the placeholders as follows:</p> <ul> <li><code>&lt;path-to-update-file&gt;</code>: Path to the update file created in step 9 (e.g., <code>api/apidata/upd/1.json</code>).</li> <li><code>&lt;collection-owner&gt;</code>: Address of the NFT collection owner.</li> <li><code>&lt;collection-meta&gt;</code>: Full URL to the collection metadata file (e.g., <code>https://yourdomain.com/collection.json</code>).</li> <li><code>&lt;item-meta-prefix&gt;</code>: Common prefix for item metadata (for example, if item 0 has metadata at <code>https://yourdomain.com/0.json</code>, use <code>https://yourdomain.com/</code>).</li> <li><code>&lt;royalty-base&gt;</code>: Numerator for royalties (for example, <code>10</code> for 10% if royalty-factor is 100).</li> <li><code>&lt;royalty-factor&gt;</code>: Denominator for royalties (for example, <code>100</code>).</li> <li><code>&lt;royalty-recipient&gt;</code>: Address receiving royalties (this can be the same as <code>&lt;collection-owner&gt;</code>).</li> <li><code>&lt;api-uri-including-v1&gt;</code>: Public API URL with the <code>/v1</code> postfix (for example, if you used <code>https://yourapi.com/admin/rediscover</code> to generate the update file, use <code>https://yourapi.com/v1</code> here).</li> <li>Invoke the <code>ton://</code> deeplink After generating the update, a <code>ton://</code> link appears in the console logs. Follow the link and confirm the transaction. For convenience, you can paste the link into a QR code generator and scan the QR code with the Tonhub wallet (on testnet or mainnet).</li> </ul> </li> <li> <p>Set the collection address     In your browser, navigate to <code>&lt;API_URI&gt;/admin/setaddr/&lt;collection-address&gt;</code>, replacing <code>&lt;collection-address&gt;</code> with the address observed during the deployment step.</p> </li> <li> <p>Wait for confirmation     Monitor the container API logs until you see a message indicating a <code>committed state</code>.</p> <pre><code>docker-compose logs api \n</code></pre> </li> <li> <p>Deployment complete!</p> </li> </ol>"},{"location":"cookbook/cnft/#run-claiming-bot","title":"Run Claiming Bot","text":"<ol> <li> <p>Update the <code>.env</code> file     Add the <code>COLLECTION_ADDRESS</code> obtained during deployment to your <code>.env</code> file.</p> </li> <li> <p>Start the Telegram bot     Run the following command to start the bot:</p> <pre><code>docker-compose up -d redis bot \n</code></pre> </li> <li> <p>Interact with the bot     Open Telegram, navigate to your bot, and follow its instructions to claim NFTs or perform other actions.</p> </li> <li> <p>Done!</p> </li> </ol>"},{"location":"cookbook/cnft/#updating-owners","title":"Updating owners","text":"<p>Follow these steps to update the list of owners and integrate the changes into your NFT collection:</p> <ol> <li> <p>Prepare the new owners file     Create a <code>new-owners.txt</code> file with the new owner addresses and place it in the <code>api</code> folder.</p> </li> <li> <p>Add new owners     Run:</p> <pre><code>docker-compose exec api /ctl add /api/new-owners.txt \n</code></pre> </li> <li> <p>Rediscover items     In your browser, navigate to <code>&lt;API_URI&gt;/admin/rediscover</code> and log in with your <code>ADMIN_USERNAME</code> and <code>ADMIN_PASSWORD</code>.</p> </li> <li> <p>Locate the update file     After rediscovering, locate the new update file in the <code>api/apidata/upd</code> folder (for example, <code>2.json</code> if the previous update was <code>1.json</code>).</p> </li> <li> <p>Generate an update     Run:</p> <pre><code>docker-compose exec api /ctl genupd &lt;path-to-update-file&gt; &lt;collection-address&gt; \n</code></pre> <p>Replace <code>&lt;path-to-update-file&gt;</code> with the new update file\u2019s path (e.g., <code>api/apidata/upd/2.json</code>) and <code>&lt;collection-address&gt;</code> with the NFT collection address.</p> </li> <li> <p>Invoke the <code>ton://</code> deeplink     Follow the generated <code>ton://</code> link and confirm the transaction. You may also generate a QR code from the link and scan it with the Tonhub wallet.</p> </li> <li> <p>Wait for confirmation     Monitor the container API logs until you see a message indicating a <code>committed state</code>.</p> <pre><code>docker-compose logs api \n</code></pre> </li> <li> <p>Done!</p> </li> </ol>"},{"location":"cookbook/cnft/#conclusion","title":"Conclusion","text":"<p>The Compressed NFT standard transforms the creation and management of NFT collections by offering a scalable, cost-effective solution for mass NFT production. By addressing the limitations of existing standards, this approach paves the way for broader adoption and innovative applications of NFT technology in community building and marketing campaigns.</p>"},{"location":"cookbook/cnft/#see-also","title":"See also","text":"<ul> <li>Compressed NFT standard implementation</li> <li>Reference augmenting API implementation</li> <li>Compressed NFT toolbox</li> </ul>"},{"location":"cookbook/subdomains/","title":"Minting TON DNS Subdomains","text":""},{"location":"cookbook/subdomains/#introduction","title":"Introduction","text":"<p>This guide walks you through creating and managing subdomains on the TON blockchain using open-source tools. It covers deploying subdomain management contracts, issuing subdomains, and managing DNS records with practical examples.</p>"},{"location":"cookbook/subdomains/#implementation","title":"Implementation","text":"<p>There are two open-source implementations available for managing subdomains on TON, depending on the level of complexity and control you need:</p>"},{"location":"cookbook/subdomains/#subdomain-collection","title":"Subdomain Collection","text":"<p>GitHub \u2197</p> <p>This is a more advanced solution where each subdomain is represented as an NFT. The owner of the collection is responsible for issuing subdomains, while each NFT owner has full control over their subdomain.</p> <p>Key Features:</p> <ul> <li>Subdomains can be transferred or sold</li> <li>Decentralized record management \u2014 each subdomain has its own smart contract</li> <li>Requires additional infrastructure (e.g., metadata API)</li> </ul>"},{"location":"cookbook/subdomains/#subdomain-manager","title":"Subdomain Manager","text":"<p>GitHub \u2197</p> <p>This is a basic implementation where a single smart contract acts as the centralized subdomain manager. The administrator is responsible for issuing subdomains and configuring their DNS records.</p> <p>Key Features:</p> <ul> <li>Suitable for simple use cases</li> <li>Quick and easy setup</li> <li>Centralized control through one smart contract</li> </ul>"},{"location":"cookbook/subdomains/#environment-setup","title":"Environment Setup","text":"<p>This guide uses Python along with the open-source tonutils library, which supports both subdomain management implementations.</p>"},{"location":"cookbook/subdomains/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+</li> <li>A registered .ton domain:</li> <li>Mainnet: dns.ton.org</li> <li>Testnet: dns.ton.org?testnet=true</li> </ul>"},{"location":"cookbook/subdomains/#install-dependencies","title":"Install Dependencies","text":"<p>Install the required Python library:</p> <pre><code>pip install tonutils\n</code></pre>"},{"location":"cookbook/subdomains/#additional-requirements-for-subdomain-collection","title":"Additional Requirements for Subdomain Collection","text":"<p>If you\u2019re using the Subdomain Collection approach, you\u2019ll also need:</p> <ul> <li>A server to host the metadata API</li> <li>A domain name pointing to that server for metadata access</li> <li>Docker and Docker Compose for easy deployment of the API</li> </ul>"},{"location":"cookbook/subdomains/#subdomain-collection_1","title":"Subdomain Collection","text":""},{"location":"cookbook/subdomains/#metadata-setup","title":"Metadata Setup","text":"<p>Before deploying the subdomain collection, you need to launch the metadata API. This service is responsible for generating dynamic images and attributes for your subdomain NFTs, making them visually identifiable.</p> <ol> <li> <p>Clone the repository:    <pre><code>git clone https://github.com/nessshon/subdomains-toolbox\ncd metadata-api\n</code></pre></p> </li> <li> <p>Start the API using Docker:    The API will be running on port <code>8001</code>. You will need to configure SSL and set up a reverse proxy to expose it    securely.    <pre><code>docker-compose up -d\n</code></pre></p> </li> <li> <p>Test the API:    Visit <code>https://your-domain.com/api/ton/example.png</code> in your browser. If set up correctly, you\u2019ll see a generated    image for the subdomain <code>example</code>.</p> </li> </ol>"},{"location":"cookbook/subdomains/#deploy-the-collection","title":"Deploy the Collection","text":"<p>Once the API is running, you can deploy the NFT collection smart contract for your subdomains.</p> <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns import Domain\nfrom tonutils.dns.subdomain_collection import SubdomainCollection\nfrom tonutils.dns.subdomain_collection.content import SubdomainCollectionContent\nfrom tonutils.dns.subdomain_collection.data import FullDomain\nfrom tonutils.nft.royalty_params import RoyaltyParams\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import TransferData\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# NFT domain name and address from TON DNS Domains\n# Obtainable from https://dns.ton.org/ or https://dns.ton.org/?testnet=true\nDOMAIN_NAME = \"ghost\"  # ghost \u2192 ghost.ton\nDOMAIN_ADDRESS = \"EQ...\"\n\n# Royalty parameters: base and factor for calculating the royalty\nROYALTY_BASE = 1000\nROYALTY_FACTOR = 55  # 5.5% royalty\n\n# Base URL of the API for generating metadata for NFTs\n# API source code: https://github.com/nessshon/subdomains-toolbox\nAPI_BASE_URL = \"https://your-domain.com/api/ton/\"\n\n# Metadata for the NFT collection\nCOLLECTION_METADATA = {\n  \"name\": f\"{DOMAIN_NAME.title()} DNS Domains\",\n  \"image\": f\"{API_BASE_URL}{DOMAIN_NAME}.png\",\n  \"description\": f\"*.{DOMAIN_NAME}.ton domains\",\n  \"prefix_uri\": API_BASE_URL,\n}\n\"\"\"\nExample of the metadata for the NFT collection (JSON format):\n{\n    \"name\": \"Ghost DNS Domains\",\n    \"image\": \"https://your-domain.com/api/ton/ghost.png\",\n    \"description\": \"*.ghost.ton domains\",\n    \"prefix_uri\": \"https://your-domain.com/api/ton/\"\n}\n\"\"\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  collection = SubdomainCollection(\n    owner_address=wallet.address,\n    content=SubdomainCollectionContent(**COLLECTION_METADATA),\n    royalty_params=RoyaltyParams(\n      base=ROYALTY_BASE,\n      factor=ROYALTY_FACTOR,\n      address=wallet.address,\n    ),\n    full_domain=FullDomain(DOMAIN_NAME, \"ton\"),\n  )\n\n  tx_hash = await wallet.batch_transfer(\n    [\n      # Deploy collection\n      TransferData(\n        destination=collection.address,\n        amount=0.05,\n        body=collection.build_deploy_body(),\n        state_init=collection.state_init,\n      ),\n      # Bind Subdomain Collection to the main domain\n      TransferData(\n        destination=DOMAIN_ADDRESS,\n        amount=0.05,\n        body=Domain.build_set_next_resolver_record_body(collection.address),\n      ),\n    ]\n  )\n\n  print(f\"Successfully deployed Subdomain Collection at address: {collection.address.to_str()}\")\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre>"},{"location":"cookbook/subdomains/#minting-subdomains","title":"Minting Subdomains","text":"<p>To mint a new subdomain as an NFT:</p> <ol> <li>Open your TON wallet (e.g., Tonkeeper).</li> <li>Send 0.1 TON to the Subdomain Collection contract address (printed during deployment).</li> <li>In the transaction comment field, enter the desired subdomain name (e.g., <code>alice</code> for <code>alice.ghost.ton</code>).</li> <li>Ensure the subdomain name is valid (alphanumeric, no special characters) and not already minted.</li> <li>After the transaction is confirmed, the subdomain NFT will be sent to your wallet.</li> </ol>"},{"location":"cookbook/subdomains/#managing-records","title":"Managing Records","text":""},{"location":"cookbook/subdomains/#setting-records","title":"Setting Records","text":"<p>The record-setting mechanism for NFT subdomains is similar to the one used in the TON DNS Domains collection. You can assign one of the following record types to a subdomain \u2014 examples for each are provided below.</p> Set Wallet Record <pre><code>import asyncio\nfrom pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n# Address of the wallet to be set (e.g., UQ...)\nWALLET_ADDRESS = \"UQ...\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = Domain.build_set_wallet_record_body(Address(WALLET_ADDRESS))\n\n  tx_hash = await wallet.transfer(\n    destination=NFT_DOMAIN_ADDRESS,\n    amount=0.005,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre> Set Site Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n# ADNL address (e.g., \"a1b2c3...\")\nADNL_ADDRESS = \"a1b2c3...\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = Domain.build_set_site_record_body(ADNL_ADDRESS)\n\n  tx_hash = await wallet.transfer(\n    destination=NFT_DOMAIN_ADDRESS,\n    amount=0.005,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre> Set TON Storage Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n# Hex-encoded BAG ID (e.g., \"1234567890abcdef...\")\nBAG_ID = \"1234567890abcdef...\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = Domain.build_set_storage_record_body(BAG_ID)\n\n  tx_hash = await wallet.transfer(\n    destination=NFT_DOMAIN_ADDRESS,\n    amount=0.005,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre> Set Next Resolver Record <pre><code>import asyncio\n\nfrom pytoniq_core import Address\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n# Address of the next resolver contract (e.g., EQ...)\nCONTRACT_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = Domain.build_set_next_resolver_record_body(Address(CONTRACT_ADDRESS))\n\n  tx_hash = await wallet.transfer(\n    destination=NFT_DOMAIN_ADDRESS,\n    amount=0.005,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre>"},{"location":"cookbook/subdomains/#deleting-records","title":"Deleting Records","text":"<p>Similarly, you can delete existing records. Below are examples for each type.</p> Delete Wallet Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = Domain.build_delete_wallet_record_body()\n\n  tx_hash = await wallet.transfer(\n    destination=NFT_DOMAIN_ADDRESS,\n    amount=0.005,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre> Delete Site Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = Domain.build_delete_site_record_body()\n\n  tx_hash = await wallet.transfer(\n    destination=NFT_DOMAIN_ADDRESS,\n    amount=0.005,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre> Delete TON Storage Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = Domain.build_delete_storage_record_body()\n\n  tx_hash = await wallet.transfer(\n    destination=NFT_DOMAIN_ADDRESS,\n    amount=0.005,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre> Delete Next Resolver Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = Domain.build_delete_next_resolver_record_body()\n\n  tx_hash = await wallet.transfer(\n    destination=NFT_DOMAIN_ADDRESS,\n    amount=0.005,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre>"},{"location":"cookbook/subdomains/#subdomain-manager_1","title":"Subdomain Manager","text":""},{"location":"cookbook/subdomains/#deploy-the-manager","title":"Deploy the Manager","text":"<p>Below is an example of how to deploy the Subdomain Manager using the tonutils Python library. This script initializes the smart contract, links it to the main domain, and sends the necessary transactions from your wallet.</p> <pre><code>import asyncio\nfrom pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns import Domain\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import TransferData\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Administrator address for managing the Subdomain Manager (e.g., UQ...)\nADMIN_ADDRESS = \"UQ...\"\n\n# NFT address of the main domain from TON DNS Domains collection (e.g., EQ...)\nDOMAIN_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  subdomain_manager = SubdomainManager(Address(ADMIN_ADDRESS))\n\n  tx_hash = await wallet.batch_transfer(\n    [\n      # Deploy Subdomain Manager\n      TransferData(\n        destination=subdomain_manager.address,\n        amount=0.05,\n        state_init=subdomain_manager.state_init,\n      ),\n      # Bind Subdomain Manager to the main domain as a next resolver\n      TransferData(\n        destination=DOMAIN_ADDRESS,\n        amount=0.05,\n        body=Domain.build_set_next_resolver_record_body(subdomain_manager.address),\n      ),\n    ]\n  )\n\n  print(f\"Successfully deployed Subdomain Manager at address: {subdomain_manager.address.to_str()}\")\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre>"},{"location":"cookbook/subdomains/#setting-records_1","title":"Setting Records","text":"<p>You can set one of the following record types for a subdomain. Below are examples for each.</p> Set Wallet Record <pre><code>import asyncio\nfrom pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# Address of the wallet to be set for the subdomain (e.g., UQ...)\nWALLET_ADDRESS = \"UQ...\"\n\n# Subdomain to be registered (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = SubdomainManager.build_set_wallet_record_body(SUBDOMAIN, Address(WALLET_ADDRESS))\n\n  tx_hash = await wallet.transfer(\n    destination=SUBDOMAIN_MANAGER_ADDRESS,\n    amount=0.02,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre> Set Site Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# ADNL address for the subdomain (e.g., \"a1b2c3...\")\nADNL_ADDRESS = \"a1b2c3...\"\n\n# Subdomain to be registered (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = SubdomainManager.build_set_site_record_body(SUBDOMAIN, ADNL_ADDRESS)\n\n  tx_hash = await wallet.transfer(\n    destination=SUBDOMAIN_MANAGER_ADDRESS,\n    amount=0.02,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre> Set TON Storage Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# ID of the storage bag (hex string, e.g., \"1234567890abcdef...\")\nBAG_ID = \"1234567890abcdef...\"\n\n# Subdomain to be registered (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = SubdomainManager.build_set_storage_record_body(SUBDOMAIN, BAG_ID)\n\n  tx_hash = await wallet.transfer(\n    destination=SUBDOMAIN_MANAGER_ADDRESS,\n    amount=0.02,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre> Set Next Resolver Record <pre><code>import asyncio\n\nfrom pytoniq_core import Address\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# Address of the next resolver contract (e.g., EQ...)\nCONTRACT_ADDRESS = \"EQ...\"\n\n# Subdomain to be registered (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = SubdomainManager.build_set_next_resolver_record_body(SUBDOMAIN, Address(CONTRACT_ADDRESS))\n\n  tx_hash = await wallet.transfer(\n    destination=SUBDOMAIN_MANAGER_ADDRESS,\n    amount=0.02,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre>"},{"location":"cookbook/subdomains/#deleting-records_1","title":"Deleting Records","text":"<p>Similarly, you can delete existing records. Below are examples for each type.</p> Delete Wallet Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# Subdomain to be deleted (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = SubdomainManager.build_delete_wallet_record_body(SUBDOMAIN)\n\n  tx_hash = await wallet.transfer(\n    destination=SUBDOMAIN_MANAGER_ADDRESS,\n    amount=0.02,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre> Delete Site Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# Subdomain to be deleted (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = SubdomainManager.build_delete_site_record_body(SUBDOMAIN, False)\n\n  tx_hash = await wallet.transfer(\n    destination=SUBDOMAIN_MANAGER_ADDRESS,\n    amount=0.02,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre> Delete TON Storage Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# Subdomain to be deleted (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = SubdomainManager.build_delete_storage_record_body(SUBDOMAIN, True)\n\n  tx_hash = await wallet.transfer(\n    destination=SUBDOMAIN_MANAGER_ADDRESS,\n    amount=0.02,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre> Delete Next Resolver Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# Subdomain to be deleted (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = SubdomainManager.build_delete_next_resolver_record_body(SUBDOMAIN)\n\n  tx_hash = await wallet.transfer(\n    destination=SUBDOMAIN_MANAGER_ADDRESS,\n    amount=0.02,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre>"},{"location":"cookbook/subdomains/#conclusion","title":"Conclusion","text":"<p>TON blockchain offers flexible options for subdomain management, whether you prefer a centralized approach with the Subdomain Manager or a decentralized, NFT-based solution with the Subdomain Collection. Both solutions are easy to implement and provide powerful tools to manage your subdomains and DNS records efficiently. This guide provides all the necessary steps to get started and take control of your subdomains on TON.</p>"},{"location":"cookbook/subdomains/#see-also","title":"See also","text":"<ul> <li>TON Subdomains Toolbox</li> <li>Subdomain Manager Contract</li> <li>Subdomain Collection Contract</li> </ul>"},{"location":"cookbook/ton-connect/sending-transactions/","title":"Sending transactions","text":"<p>This guide provides step-by-step instructions for integrating and managing transaction sending using the <code>TonConnect</code> from the <code>tonutils</code> library. Whether you're a beginner or an experienced developer, this cookbook will help you implement transaction functionality efficiently.</p>"},{"location":"cookbook/ton-connect/sending-transactions/#installation","title":"Installation","text":"<p>Install the necessary Python packages using <code>pip</code>:</p> <pre><code>pip install tonutils aiofiles\n</code></pre>"},{"location":"cookbook/ton-connect/sending-transactions/#configuration","title":"Configuration","text":""},{"location":"cookbook/ton-connect/sending-transactions/#create-tonconnect-manifest","title":"Create TonConnect Manifest","text":"<p>Create a JSON file describing your application. This manifest is displayed in the wallet during connection.</p> <pre><code>{\n  \"url\": \"&lt;app-url&gt;\",                        // required\n  \"name\": \"&lt;app-name&gt;\",                      // required\n  \"iconUrl\": \"&lt;app-icon-url&gt;\",               // required\n  \"termsOfUseUrl\": \"&lt;terms-of-use-url&gt;\",     // optional\n  \"privacyPolicyUrl\": \"&lt;privacy-policy-url&gt;\" // optional\n}\n</code></pre> <p>Note</p> <p>Ensure this file is publicly accessible via its URL.</p>"},{"location":"cookbook/ton-connect/sending-transactions/#storage-implementation","title":"Storage Implementation","text":"<p>The <code>FileStorage</code> class manages persistent storage of connection data using a JSON file.</p> <pre><code>import json\nimport os\nfrom asyncio import Lock\nfrom typing import Optional, Dict\n\nimport aiofiles\n\nfrom tonutils.tonconnect import IStorage\n\n\nclass FileStorage(IStorage):\n\n    def __init__(self, file_path: str):\n        self.file_path = file_path\n        self.lock = Lock()\n\n        if not os.path.exists(self.file_path):\n            with open(self.file_path, 'w') as f:\n                json.dump({}, f)  # type: ignore\n\n    async def _read_data(self) -&gt; Dict[str, str]:\n        async with self.lock:\n            async with aiofiles.open(self.file_path, 'r') as f:\n                content = await f.read()\n                if content:\n                    return json.loads(content)\n                return {}\n\n    async def _write_data(self, data: Dict[str, str]) -&gt; None:\n        async with self.lock:\n            async with aiofiles.open(self.file_path, 'w') as f:\n                await f.write(json.dumps(data, indent=4))\n\n    async def set_item(self, key: str, value: str) -&gt; None:\n        data = await self._read_data()\n        data[key] = value\n        await self._write_data(data)\n\n    async def get_item(self, key: str, default_value: Optional[str] = None) -&gt; Optional[str]:\n        data = await self._read_data()\n        return data.get(key, default_value)\n\n    async def remove_item(self, key: str) -&gt; None:\n        data = await self._read_data()\n        if key in data:\n            del data[key]\n            await self._write_data(data)\n</code></pre>"},{"location":"cookbook/ton-connect/sending-transactions/#initialize-tonconnect","title":"Initialize TonConnect","text":"<p>Set up the TonConnect instance with the manifest URL and storage implementation.</p> <pre><code>from storage import FileStorage\n\nfrom tonutils.tonconnect import TonConnect\n\n# URL of the publicly hosted JSON manifest of the application\n# For detailed information: https://github.com/ton-blockchain/ton-connect/blob/main/requests-responses.md#app-manifest\nTC_MANIFEST_URL = \"https://raw.githubusercontent.com/nessshon/tonutils/main/examples/tonconnect/tonconnect-manifest.json\"\n\n# Initialize storage to save connected wallet data\n# In this example, FileStorage from storage.py is used\nTC_STORAGE = FileStorage(\"connection.json\")\n\n# Create an instance of TonConnect with the specified storage and manifest\ntc = TonConnect(storage=TC_STORAGE, manifest_url=TC_MANIFEST_URL, wallets_fallback_file_path=\"./wallets.json\")\n</code></pre>"},{"location":"cookbook/ton-connect/sending-transactions/#event-handling","title":"Event Handling","text":"<p>Handling events is essential for responding to transaction actions and errors. There are two primary methods to handle events: using decorators and using context managers.</p>"},{"location":"cookbook/ton-connect/sending-transactions/#using-decorators","title":"Using Decorators","text":"<p>Decorators associate event handlers with specific events. This method is straightforward and keeps your event handling logic organized.</p> <pre><code>@tc.on_event(Event.TRANSACTION)\nasync def on_transaction(transaction: SendTransactionResponse) -&gt; None:\n    print(f\"[Transaction SENT] Transaction successfully sent. Message hash: {transaction.normalized_hash}\")\n</code></pre>"},{"location":"cookbook/ton-connect/sending-transactions/#using-context-managers","title":"Using Context Managers","text":"<p>Context managers provide a controlled environment for handling events, ensuring proper setup and teardown.</p> <pre><code>async with connector.pending_transaction_context(rpc_request_id) as response:\n    if isinstance(response, TonConnectError):\n        print(f\"Error sending transaction: {response.message}\")\n    else:\n        print(f\"Transaction successful! Hash: {response.normalized_hash}\")\n</code></pre>"},{"location":"cookbook/ton-connect/sending-transactions/#passing-additional-parameters","title":"Passing Additional Parameters","text":"<p>In some cases, you may want to provide custom data or context to your event handlers \u2014 for example, adding tags, notes, or extra flags.</p> <p>You can achieve this by using the <code>connector.add_event_kwargs</code> method, which attaches additional keyword arguments that will be passed into the handler alongside the default parameters.</p> <p>Step 1: Add Custom Parameters</p> <p>Call <code>add_event_kwargs</code> before triggering or waiting on an event:</p> <pre><code>connector.add_event_kwargs(\n    event=Event.TRANSACTION,\n    comment=\"Hello from tonutils!\",\n)\n</code></pre> <p>Step 2: Update the Event Handler to Receive Them</p> <p>Define the handler to accept these extra parameters:</p> <pre><code>@tc.on_event(Event.TRANSACTION)\nasync def on_transaction(user_id: int, transaction: SendTransactionResponse, comment: str) -&gt; None:\n    print(f\"Comment: {comment}\")\n</code></pre> <p>Key Points:</p> <ul> <li>You can attach multiple parameters (any keyword arguments).</li> <li>The handler function must include matching parameter names.</li> <li>This mechanism works for all supported events (<code>CONNECT</code>, <code>DISCONNECT</code>, <code>TRANSACTION</code>, etc.).</li> </ul>"},{"location":"cookbook/ton-connect/sending-transactions/#sending-transactions","title":"Sending Transactions","text":""},{"location":"cookbook/ton-connect/sending-transactions/#sending-a-single-transaction","title":"Sending a Single Transaction","text":"<p>To send a single transaction, use the <code>send_transfer</code> method. This method sends a transaction to a specified destination with a certain amount and an optional message body.</p> <pre><code>rpc_request_id = await connector.send_transfer(\n    destination=connector.account.address,\n    amount=0.000000001,  # Amount in TON\n    body=\"Hello from tonutils!\",\n)\nprint(\"Request to send one transaction has been sent.\")\n</code></pre>"},{"location":"cookbook/ton-connect/sending-transactions/#sending-a-batch-of-transactions","title":"Sending a Batch of Transactions","text":"<p>To send multiple messages, use the <code>send_batch_transfer</code> method.</p> <pre><code># Get the maximum number of messages supported\nmax_messages = connector.get_max_supported_messages()\nprint(f\"Maximum number of messages: {max_messages}. Sending {max_messages} transactions...\")\n\nrpc_request_id = await connector.send_batch_transfer(\n    data_list=[\n        TransferData(\n            destination=connector.account.address,\n            amount=0.000000001,\n            body=\"Hello from tonutils!\",\n        ) for _ in range(max_messages)  # Create the maximum number of messages\n    ]\n)\nprint(\"Request to send a batch of transactions has been sent.\")\n</code></pre>"},{"location":"cookbook/ton-connect/sending-transactions/#handling-transaction-status","title":"Handling Transaction Status","text":"<p>After sending a transaction, you may want to check its status to determine if it has been confirmed by the user in the wallet.</p> <pre><code># Get the transaction status (whether it has been confirmed by the user in the wallet)\nis_pending = connector.is_transaction_pending(rpc_request_id)\nprint(f\"Transaction is pending confirmation: {is_pending}\")\n\n# Use a context manager to get the transaction result by rpc_request_id\nasync with connector.pending_transaction_context(rpc_request_id) as response:\n    if isinstance(response, TonConnectError):\n        print(f\"Error sending transaction: {response.message}\")\n    else:\n        print(f\"Transaction successful! Hash: {response.normalized_hash}\")\n</code></pre>"},{"location":"cookbook/ton-connect/sending-transactions/#complete-example","title":"Complete Example","text":"<p>Below is a comprehensive example demonstrating connector initialization, event handling, sending transactions, and wallet management.</p> <pre><code>import asyncio\n\nfrom storage import FileStorage\n\nfrom tonutils.tonconnect import TonConnect\nfrom tonutils.tonconnect.models import Event, EventError, SendTransactionResponse\nfrom tonutils.tonconnect.utils.exceptions import TonConnectError, UserRejectsError, RequestTimeoutError\nfrom tonutils.wallet.data import TransferData\n\n# URL of the publicly hosted JSON manifest of the application\n# For detailed information: https://github.com/ton-blockchain/ton-connect/blob/main/requests-responses.md#app-manifest\nTC_MANIFEST_URL = \"https://raw.githubusercontent.com/nessshon/tonutils/main/examples/tonconnect/tonconnect-manifest.json\"\n\n# Initialize storage to save connected wallet data\n# In this example, FileStorage from storage.py is used\nTC_STORAGE = FileStorage(\"connection.json\")\n\n# Create an instance of TonConnect with the specified storage and manifest\ntc = TonConnect(storage=TC_STORAGE, manifest_url=TC_MANIFEST_URL, wallets_fallback_file_path=\"./wallets.json\")\n\n@tc.on_event(Event.TRANSACTION)\nasync def on_transaction(transaction: SendTransactionResponse) -&gt; None:\n    \"\"\"\n    Handler for successful transaction events.\n    Processes all successful transactions and performs necessary actions.\n\n    Available handler parameters:\n    - user_id (int): User identifier\n    - transaction (SendTransactionResponse): Transaction information\n    - rpc_request_id (int): Transaction request identifier\n    - Additional parameters can be passed using `connector.add_event_kwargs(...)`\n      Example: `connector.add_event_kwargs(event=Event.TRANSACTION, comment=\"Hello from tonutils!\")`\n      In this example, `comment` is an additional parameter that will be passed to the handler.\n\n    Transaction details can be obtained from the following attributes:\n    - transaction.boc (str): BoC\n    - transaction.normalized_hash (str): Message hash\n    - transaction.cell (Cell): Transaction Cell\n    \"\"\"\n    print(f\"[Transaction SENT] Transaction successfully sent. Message hash: {transaction.normalized_hash}\")\n\n\n@tc.on_event(EventError.TRANSACTION)\nasync def on_transaction_error(error: TonConnectError) -&gt; None:\n    \"\"\"\n    Handler for transaction error events.\n    Processes all errors that occur when sending transactions.\n\n    Available handler parameters:\n    - user_id (int): User identifier\n    - error (TonConnectError): Error information\n    - rpc_request_id (int): Transaction request identifier\n    - Additional parameters can be passed using `connector.add_event_kwargs(...)`\n      Example: `connector.add_event_kwargs(event=Event.TRANSACTION, comment=\"Hello from tonutils!\")`\n      In this example, `comment` is an additional parameter that will be passed to the handler.\n\n    The type of error can be determined using isinstance:\n    - UserRejectsError: User declined the transaction.\n    - RequestTimeoutError: Send request timed out for the transaction.\n    \"\"\"\n    if isinstance(error, UserRejectsError):\n        print(f\"[Transaction ERROR] User rejected the transaction.\")\n    elif isinstance(error, RequestTimeoutError):\n        print(f\"[Transaction ERROR] Transaction request timed out.\")\n    else:\n        print(f\"[Transaction ERROR] Failed to send transaction: {error.message}\")\n\n\nasync def main() -&gt; None:\n    user_id = 12345  # Example user identifier\n\n    # Initialize the connector for the user\n    connector = await tc.init_connector(user_id)\n\n    # Start the event processing loop\n    while True:\n        # Check wallet connection\n        if not connector.connected:\n            print(\"Wallet not connected! Please connect the wallet to continue.\")\n\n            # Get all available wallets\n            wallets = await tc.get_wallets()\n\n            # As an example, we will select the wallet with index 1 (Tonkeeper)\n            selected_wallet = wallets[1]\n            connect_url = await connector.connect_wallet(selected_wallet)\n            print(f\"Please connect your wallet by visiting the following URL:\\n{connect_url}\")\n            print(\"Waiting for wallet connection...\")\n\n            async with connector.connect_wallet_context() as response:\n                if isinstance(response, TonConnectError):\n                    print(f\"Connection error: {response.message}\")\n                else:\n                    print(f\"Connected wallet: {response.account.address.to_str(is_bounceable=False)}\")\n\n        # If the wallet is connected, prompt the user to choose an action\n        call = input(\n            \"\\nChoose an action:\\n\"\n            \"1. Send a transaction\\n\"\n            \"2. Send a batch of transactions\\n\"\n            \"3. Disconnect wallet\\n\"\n            \"q. Quit\\n\"\n            \"\\nEnter your choice: \"\n        ).strip()\n\n        if call in [\"1\", \"2\"]:\n            if call == \"1\":\n                print(\"Preparing to send one transaction...\")\n                rpc_request_id = await connector.send_transfer(\n                    destination=connector.account.address,\n                    amount=0.000000001,\n                    body=\"Hello from tonutils!\",\n                )\n                print(\"Request to send one transaction has been sent.\")\n            else:\n                print(\"Preparing to send a batch of transactions...\")\n                # Get the maximum number of messages supported in a transaction\n                max_messages = connector.get_max_supported_messages()\n                print(f\"Maximum number of messages: {max_messages}. Sending {max_messages} transactions...\")\n\n                rpc_request_id = await connector.send_batch_transfer(\n                    data_list=[\n                        TransferData(\n                            destination=connector.account.address,\n                            amount=0.000000001,\n                            body=\"Hello from tonutils!\",\n                        ) for _ in range(max_messages)  # Create the maximum number of messages\n                    ]\n                )\n                print(\"Request to send a batch of transactions has been sent.\")\n\n            # Add additional parameters to be passed to event handlers\n            connector.add_event_kwargs(event=Event.TRANSACTION, comment=\"Hello from tonutils!\")\n\n            # Get the transaction status (whether it has been confirmed by the user in the wallet)\n            # Note: This is different from blockchain confirmation\n            is_pending = connector.is_transaction_pending(rpc_request_id)\n            print(f\"Transaction is pending confirmation: {is_pending}\")\n\n            # In addition to the handler, you can use a context manager to get the transaction result by rpc_request_id\n            async with connector.pending_transaction_context(rpc_request_id) as response:\n                if isinstance(response, TonConnectError):\n                    print(f\"Error sending transaction: {response.message}\")\n                else:\n                    print(f\"Transaction successful! Hash: {response.normalized_hash}\")\n\n        elif call == \"3\":\n            # Disconnect the wallet\n            await connector.disconnect_wallet()\n            print(\"Wallet successfully disconnected.\")\n\n        elif call.lower() == \"q\":\n            print(\"Exiting the program...\")\n            break\n\n        else:\n            print(\"Invalid choice! Please select a valid option.\")\n\n    # Close all TonConnect connections\n    await tc.close_all()\n\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.run(main())\n    except (KeyboardInterrupt, SystemExit):\n        # Ensure all connections are closed in case of interruption\n        asyncio.run(tc.close_all())\n</code></pre>"},{"location":"cookbook/ton-connect/sending-transactions/#conclusion","title":"Conclusion","text":"<p>By following this cookbook, you can successfully integrate TonConnect into your script enabling seamless wallet connections and transaction sending.</p>"},{"location":"cookbook/ton-connect/telegram-bot-integration/","title":"Telegram Bot Integration","text":"<p>This guide provides step-by-step instructions to integrate and manage wallet connections and transactions within a Telegram Bot using the <code>TonConnect</code> from the <code>tonutils</code> library. Whether you're a beginner or an experienced developer, this cookbook will help you implement wallet connectivity and transaction functionalities efficiently within your Telegram Bot.</p>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#installation","title":"Installation","text":"<p>Install the necessary Python packages using <code>pip</code>:</p> <pre><code>pip install tonutils aiogram redis\n</code></pre>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#structure","title":"Structure","text":"<p>Organize your project files as follows:</p> <pre><code>telegram-tonconnect-bot/\n\u251c\u2500\u2500 bot.py\n\u251c\u2500\u2500 storage.py\n</code></pre> <ul> <li>bot.py: Main bot script containing bot logic.</li> <li>storage.py: Custom storage implementation for TonConnect.</li> </ul>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#configuration","title":"Configuration","text":""},{"location":"cookbook/ton-connect/telegram-bot-integration/#create-tonconnect-manifest","title":"Create TonConnect Manifest","text":"<p>Create a JSON file describing your application. This manifest is displayed in the wallet during connection.</p> <pre><code>{\n  \"url\": \"&lt;app-url&gt;\",                        // required\n  \"name\": \"&lt;app-name&gt;\",                      // required\n  \"iconUrl\": \"&lt;app-icon-url&gt;\",               // required\n  \"termsOfUseUrl\": \"&lt;terms-of-use-url&gt;\",     // optional\n  \"privacyPolicyUrl\": \"&lt;privacy-policy-url&gt;\" // optional\n}\n</code></pre> <p>Note</p> <p>Ensure this file is publicly accessible via its URL.</p>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#storage-implementation","title":"Storage Implementation","text":"<p>TonConnect requires a storage system to manage its data. Here, we implement a Redis-based storage class.</p> <pre><code># storage.py\n\nfrom typing import Optional\n\nfrom redis.asyncio import Redis\n\nfrom tonutils.tonconnect import IStorage\n\n\nclass TCRedisStorage(IStorage):\n    def __init__(self, redis_client: Redis):\n        self.redis = redis_client\n\n    async def set_item(self, key: str, value: str) -&gt; None:\n        await self.redis.set(name=key, value=value)\n\n    async def get_item(self, key: str, default_value: Optional[str] = None) -&gt; Optional[str]:\n        value = await self.redis.get(name=key)\n        return value.decode() if value else default_value\n\n    async def remove_item(self, key: str) -&gt; None:\n        await self.redis.delete(key)\n</code></pre>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#initialization","title":"Initialization","text":"<p>Create a Python script and set up the initial configuration.</p> <pre><code># bot.py\n\nimport base64\nfrom contextlib import suppress\nfrom typing import List\n\nfrom aiogram import Dispatcher, Bot\nfrom aiogram.client.default import DefaultBotProperties\nfrom aiogram.filters import CommandStart\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.fsm.storage.redis import RedisStorage\nfrom aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, Message, CallbackQuery\nfrom aiogram.utils.keyboard import InlineKeyboardBuilder\nfrom aiogram.utils.markdown import hide_link, hcode\nfrom redis.asyncio import Redis\n\nfrom storage import TCRedisStorage\nfrom tonutils.tonconnect import TonConnect\nfrom tonutils.tonconnect.models import WalletApp, Event, EventError, SendTransactionResponse\nfrom tonutils.tonconnect.utils.exceptions import TonConnectError, UserRejectsError, RequestTimeoutError\nfrom tonutils.wallet.data import TransferData\n\nBOT_TOKEN = \"your bot token\"\nREDIS_DSN = \"redis://localhost:6379\"\nTC_MANIFEST_URL = \"https://raw.githubusercontent.com/nessshon/tonutils/main/examples/tonconnect/tonconnect-manifest.json\"\n\n# Initialize Redis\nredis = Redis.from_url(url=REDIS_DSN)\n\n# Initialize Dispatcher with Redis Storage\ndp = Dispatcher(storage=RedisStorage(redis))\n\n# Initialize Telegram Bot\nbot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode=\"HTML\"))\n\n# Initialize TonConnect\ntc = TonConnect(storage=TCRedisStorage(redis), manifest_url=TC_MANIFEST_URL, wallets_fallback_file_path=\"./wallets.json\")\n</code></pre> <ul> <li>Redis Initialization: Establishes a connection to the Redis server.</li> <li>Dispatcher &amp; Bot Initialization: Sets up the dispatcher with Redis storage and initializes the bot.</li> <li>TonConnect Initialization: Sets up TonConnect with custom Redis storage and the manifest URL.</li> </ul>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#bot-helper-functions","title":"Bot Helper Functions","text":""},{"location":"cookbook/ton-connect/telegram-bot-integration/#keyboards","title":"Keyboards","text":"<p>Functions to create various inline keyboards used in the bot.</p>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#connect-wallet-markup","title":"Connect Wallet Markup","text":"<p>Creates an inline keyboard for selecting and connecting wallets.</p> <pre><code>def _connect_wallet_markup(\n    wallets: List[WalletApp],\n    selected_wallet: WalletApp,\n    connect_url: str,\n) -&gt; InlineKeyboardMarkup:\n    wallets_buttons = [\n        InlineKeyboardButton(\n            text=f\"\u2022 {wallet.name} \u2022\" if wallet.app_name == selected_wallet.app_name else wallet.name,\n            callback_data=f\"app_wallet:{wallet.app_name}\",\n        )\n        for wallet in wallets\n    ]\n    connect_wallet_button = InlineKeyboardButton(\n        text=f\"Connect {selected_wallet.name}\",\n        url=connect_url,\n    )\n    builder = InlineKeyboardBuilder()\n    builder.row(connect_wallet_button)\n    builder.row(*wallets_buttons, width=2)\n\n    return builder.as_markup()\n</code></pre> <ul> <li>Wallet Buttons: Lists available wallets, highlighting the selected one.</li> <li>Connect Button: Provides a direct link to connect the selected wallet.</li> <li>Layout: Uses InlineKeyboardBuilder to organize buttons neatly.</li> </ul>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#confirm-transaction-markup","title":"Confirm Transaction Markup","text":"<p>Creates an inline keyboard for confirming or canceling a transaction.</p> <pre><code>def _confirm_transaction_markup(url: str, wallet_name: str) -&gt; InlineKeyboardMarkup:\n    return InlineKeyboardMarkup(\n        inline_keyboard=[\n            [InlineKeyboardButton(text=f\"Open {wallet_name}\", url=url)],\n            [InlineKeyboardButton(text=\"Cancel\", callback_data=\"cancel_transaction\")],\n        ]\n    )\n</code></pre> <ul> <li>Open Wallet Button: Directs the user to their wallet for transaction confirmation.</li> <li>Cancel Button: Allows the user to cancel the pending transaction.</li> </ul>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#choose-action-markup","title":"Choose Action Markup","text":"<p>Creates an inline keyboard for selecting actions after wallet connection.</p> <pre><code>def _choose_action_markup() -&gt; InlineKeyboardMarkup:\n    builder = InlineKeyboardBuilder()\n    builder.row(InlineKeyboardButton(text=\"Send transaction\", callback_data=\"send_transaction\"))\n    builder.row(InlineKeyboardButton(text=\"Send batch transaction\", callback_data=\"send_batch_transaction\"))\n    builder.row(InlineKeyboardButton(text=\"Disconnect wallet\", callback_data=\"disconnect_wallet\"))\n\n    return builder.as_markup()\n</code></pre> <ul> <li>Actions: Users can choose to send a single transaction, send multiple transactions in a batch, or disconnect their wallet.</li> </ul>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#go-to-main-menu-markup","title":"Go to Main Menu Markup","text":"<p>Creates an inline keyboard to navigate back to the main menu.</p> <pre><code>def _go_to_main_menu_markup() -&gt; InlineKeyboardMarkup:\n    builder = InlineKeyboardBuilder()\n    builder.row(InlineKeyboardButton(text=\"Main menu\", callback_data=\"main_menu\"))\n\n    return builder.as_markup()\n</code></pre> <ul> <li>Main Menu Button: Provides a way for users to return to the primary interface.</li> </ul>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#windows","title":"Windows","text":"<p>Define various user interface windows that respond to user interactions and TonConnect events.</p>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#connect-wallet-window","title":"Connect Wallet Window","text":"<p>Displays the wallet connection interface to the user.</p> <pre><code>async def connect_wallet_window(state: FSMContext, user_id: int) -&gt; None:\n    connector = await tc.init_connector(user_id)\n    state_data = await state.get_data()\n    wallets = await tc.get_wallets()\n\n    selected_wallet = state_data.get(\"selected_wallet\", wallets[0].app_name)\n    selected_wallet = next(wallet for wallet in wallets if wallet.app_name == selected_wallet)\n    connect_url = await connector.connect_wallet(wallet_app=selected_wallet)\n\n    qrcode_url = (\n        f\"https://qrcode.ness.su/create?\"\n        f\"box_size=20&amp;border=7&amp;image_padding=20\"\n        f\"&amp;data={base64.b64encode(connect_url.encode()).decode()}\"\n        f\"&amp;image_url={base64.b64encode(selected_wallet.image.encode()).decode()}\"\n    )\n\n    text = f\"{hide_link(qrcode_url)}Connect your wallet!\"\n    reply_markup = _connect_wallet_markup(wallets, selected_wallet, connect_url)\n\n    message = await bot.send_message(chat_id=user_id, text=text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n</code></pre> <ul> <li>Connector Initialization: Prepares the TonConnect connector for the user.</li> <li>Wallet Selection: Retrieves available wallets and selects the preferred one.</li> <li>QR Code Generation: Generates a QR code URL for wallet connection.</li> <li>User Prompt: Sends a message prompting the user to connect their wallet with the appropriate inline keyboard.</li> </ul>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#wallet-connected-window","title":"Wallet Connected Window","text":"<p>Displays the connected wallet information and available actions.</p> <pre><code>async def wallet_connected_window(user_id: int) -&gt; None:\n    connector = await tc.init_connector(user_id)\n    wallet_address = connector.wallet.account.address.to_str(is_bounceable=False)\n\n    reply_markup = _choose_action_markup()\n    text = f\"Connected wallet:\\n{hcode(wallet_address)}\\n\\nChoose an action:\"\n\n    message = await bot.send_message(chat_id=user_id, text=text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n</code></pre> <ul> <li>Wallet Information: Shows the connected wallet's address.</li> <li>Available Actions: Presents options to send transactions, send batch transactions, or disconnect the wallet.</li> </ul>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#send-transaction-window","title":"Send Transaction Window","text":"<p>Prompts the user to confirm the transaction in their wallet.</p> <pre><code>async def send_transaction_window(user_id: int) -&gt; None:\n    connector = await tc.init_connector(user_id)\n    reply_markup = _confirm_transaction_markup(\n        url=connector.wallet_app.direct_url,\n        wallet_name=connector.wallet_app.name,\n    )\n\n    text = \"Please confirm the transaction in your wallet.\"\n\n    message = await bot.send_message(chat_id=user_id, text=text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n</code></pre> <ul> <li>User Prompt: Instructs the user to confirm the transaction within their wallet.</li> <li>Confirmation Options: Provides buttons to open the wallet or cancel the transaction.</li> </ul>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#transaction-sent-window","title":"Transaction Sent Window","text":"<p>Displays the transaction details after a successful send.</p> <pre><code>async def transaction_sent_window(user_id: int, transaction: SendTransactionResponse) -&gt; None:\n    text = (\n        \"Transaction sent!\\n\\n\"\n        f\"Transaction msg hash:\\n{hcode(transaction.normalized_hash)}\\n\"\n        f\"Transaction BoC:\\n{hcode(transaction.boc)}\\n\"\n    )\n    reply_markup = _go_to_main_menu_markup()\n\n    message = await bot.send_message(chat_id=user_id, text=text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n</code></pre> <ul> <li>Transaction Details: Provides the transaction hash and BoC (Bag of Cells) for reference.</li> <li>Navigation: Offers a button to return to the main menu.</li> </ul>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#error-window","title":"Error Window","text":"<p>Displays error messages with an option to retry or go back.</p> <pre><code>async def error_window(user_id: int, message_text: str, button_text: str, callback_data: str) -&gt; None:\n    builder = InlineKeyboardBuilder()\n    builder.row(InlineKeyboardButton(text=button_text, callback_data=callback_data))\n    reply_markup = builder.as_markup()\n\n    message = await bot.send_message(chat_id=user_id, text=message_text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n</code></pre> <ul> <li>Error Message: Communicates the issue to the user.</li> <li>Retry Option: Provides a button to attempt the failed action again or navigate elsewhere.</li> </ul>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#utils","title":"Utils","text":"<p>Function to delete the last message sent to the user to keep the chat clean.</p> <pre><code>async def delete_last_message(user_id: int, message_id: int) -&gt; None:\n    state = dp.fsm.resolve_context(bot, user_id, user_id)\n    last_message_id = (await state.get_data()).get(\"last_message_id\")\n\n    if last_message_id is not None:\n        with suppress(Exception):\n            await bot.delete_message(chat_id=user_id, message_id=last_message_id)\n\n    await state.update_data(last_message_id=message_id)\n</code></pre> <ul> <li>Purpose: Ensures that only the latest message is visible to the user, enhancing the user experience by reducing   clutter.</li> <li>Functionality:<ul> <li>Retrieves the last message ID from the user's state data.</li> <li>Attempts to delete the last message if it exists.</li> <li>Updates the state with the new message ID.</li> </ul> </li> </ul>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#tonconnect-handlers","title":"TonConnect handlers","text":"<p>TonConnect utilizes event-driven architecture to handle various wallet-related actions. This section outlines how to handle these events within your bot.</p>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#connect-event","title":"Connect Event","text":"<p>Handler for successful wallet connection events.</p> <pre><code>@tc.on_event(Event.CONNECT)\nasync def connect_event(user_id: int) -&gt; None:\n    await wallet_connected_window(user_id)\n</code></pre> <ul> <li>Trigger: When a wallet is successfully connected.</li> <li>Action: Displays the connected wallet information and available actions to the user.</li> </ul>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#connect-error-event","title":"Connect Error Event","text":"<p>Handler for wallet connection errors.</p> <pre><code>@tc.on_event(EventError.CONNECT)\nasync def connect_error_event(error: TonConnectError, user_id: int) -&gt; None:\n    button_text, callback_data = \"Try again\", \"connect_wallet\"\n    if isinstance(error, UserRejectsError):\n        message_text = \"You rejected the wallet connection.\"\n    elif isinstance(error, RequestTimeoutError):\n        message_text = \"Connection request timed out.\"\n    else:\n        message_text = f\"Connection error. Error: {error.message}\"\n    await error_window(user_id, message_text, button_text, callback_data)\n</code></pre> <ul> <li>Error Types:<ul> <li>UserRejectsError: User declined the connection.</li> <li>RequestTimeoutError: Connection request timed out.</li> <li>Other errors: Generic connection issues.</li> </ul> </li> <li>Action: Displays an error message with an option to retry.</li> </ul>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#disconnect-event","title":"Disconnect Event","text":"<p>Handler for successful wallet disconnection events.</p> <pre><code>@tc.on_event(Event.DISCONNECT)\nasync def disconnect_event(user_id: int) -&gt; None:\n    state = dp.fsm.resolve_context(bot, user_id, user_id)\n    await connect_wallet_window(state, user_id)\n</code></pre> <ul> <li>Trigger: When a wallet is successfully disconnected.</li> <li>Action: Prompts the user to reconnect their wallet.</li> </ul>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#disconnect-error-event","title":"Disconnect Error Event","text":"<p>Handler for wallet disconnection errors.</p> <pre><code>@tc.on_event(EventError.DISCONNECT)\nasync def disconnect_error_event(error: TonConnectError, user_id: int) -&gt; None:\n    button_text, callback_data = \"Try again\", \"connect_wallet\"\n    if isinstance(error, UserRejectsError):\n        message_text = \"You rejected the wallet disconnection.\"\n    elif isinstance(error, RequestTimeoutError):\n        message_text = \"Disconnect request timed out.\"\n    else:\n        message_text = f\"Disconnect error. Error: {error.message}\"\n\n    await error_window(user_id, message_text, button_text, callback_data)\n</code></pre> <ul> <li>Error Types:<ul> <li>UserRejectsError: User declined the disconnection.</li> <li>RequestTimeoutError: Disconnection request timed out.</li> <li>Other errors: Generic disconnection issues.</li> </ul> </li> <li>Action: Displays an error message with an option to retry.</li> </ul>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#transaction-event","title":"Transaction Event","text":"<p>Handler for successful transaction events.</p> <pre><code>@tc.on_event(Event.TRANSACTION)\nasync def transaction_event(user_id: int, transaction: SendTransactionResponse) -&gt; None:\n    await transaction_sent_window(user_id, transaction)\n</code></pre> <ul> <li>Trigger: When a transaction is successfully sent.</li> <li>Action: Displays transaction details to the user</li> </ul>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#transaction-error-event","title":"Transaction Error Event","text":"<p>Handler for transaction errors.</p> <pre><code>@tc.on_event(EventError.TRANSACTION)\nasync def transaction_error_event(error: TonConnectError, user_id: int) -&gt; None:\n    button_text, callback_data = \"Try again\", \"main_menu\"\n    if isinstance(error, UserRejectsError):\n        message_text = \"You rejected the transaction.\"\n    elif isinstance(error, RequestTimeoutError):\n        message_text = \"Transaction request timed out.\"\n    else:\n        message_text = f\"Transaction error. Error: {error.message}\"\n\n    await error_window(user_id, message_text, button_text, callback_data)\n</code></pre> <ul> <li>Error Types:<ul> <li>UserRejectsError: User declined the transaction.</li> <li>RequestTimeoutError: Transaction request timed out.</li> <li>Other errors: Generic transaction issues.</li> </ul> </li> <li>Action: Displays an error message with an option to return to the main menu.</li> </ul>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#bot-handlers","title":"Bot handlers","text":"<p>Here's how the bot's functionalities come together in handling various scenarios.</p>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#start-command-handler","title":"Start Command Handler","text":"<p>Handles the /start command to initiate the wallet connection process or display connected wallet actions.</p> <pre><code>@dp.message(CommandStart())\nasync def start_command(message: Message, state: FSMContext) -&gt; None:\n    connector = await tc.init_connector(message.from_user.id)\n    rpc_request_id = (await state.get_data()).get(\"rpc_request_id\")\n    if connector.is_transaction_pending(rpc_request_id):\n        connector.cancel_pending_transaction(rpc_request_id)\n\n    if not connector.connected:\n        await connect_wallet_window(state, message.from_user.id)\n    else:\n        await wallet_connected_window(message.from_user.id)\n</code></pre> <ul> <li>Initialization: Prepares the connector for the user.</li> <li>Pending Transactions: Cancels any ongoing transactions to prevent conflicts.</li> <li>Connection Status: Determines whether to prompt for wallet connection or display available actions.</li> </ul>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#callback-query-handler","title":"Callback Query Handler","text":"<p>Handles various callback queries from inline buttons.</p> <pre><code>@dp.callback_query()\nasync def callback_query_handler(callback_query: CallbackQuery, state: FSMContext) -&gt; None:\n    connector = await tc.init_connector(callback_query.from_user.id)\n    rpc_request_id = (await state.get_data()).get(\"rpc_request_id\")\n\n    if callback_query.data.startswith(\"app_wallet:\"):\n        selected_wallet = callback_query.data.split(\":\")[1]\n        await state.update_data(selected_wallet=selected_wallet)\n        await connect_wallet_window(state, callback_query.from_user.id)\n\n    elif callback_query.data == \"main_menu\":\n        await wallet_connected_window(callback_query.from_user.id)\n\n    elif callback_query.data == \"connect_wallet\":\n        await connect_wallet_window(state, callback_query.from_user.id)\n\n    elif callback_query.data == \"disconnect_wallet\":\n        connector.add_event_kwargs(Event.DISCONNECT, state=state)\n        await connector.disconnect_wallet()\n\n    elif callback_query.data == \"cancel_transaction\":\n        if connector.is_transaction_pending(rpc_request_id):\n            connector.cancel_pending_transaction(rpc_request_id)\n        await wallet_connected_window(callback_query.from_user.id)\n\n    elif callback_query.data == \"send_transaction\":\n        rpc_request_id = await connector.send_transfer(\n            destination=connector.account.address,\n            amount=0.000000001,\n            body=\"Hello from tonutils!\",\n        )\n        await send_transaction_window(callback_query.from_user.id)\n        await state.update_data(rpc_request_id=rpc_request_id)\n\n    elif callback_query.data == \"send_batch_transaction\":\n        transfer_data = [\n            TransferData(\n                destination=connector.account.address,\n                amount=0.000000001,\n                body=\"Hello from tonutils!\",\n            ) for _ in range(4)\n        ]\n        rpc_request_id = await connector.send_batch_transfer(transfer_data)\n        await send_transaction_window(callback_query.from_user.id)\n        await state.update_data(rpc_request_id=rpc_request_id)\n\n    await callback_query.answer()\n</code></pre> <ul> <li>Wallet Selection (<code>app_wallet</code>:): Updates the selected wallet and prompts the user to reconnect.</li> <li>Main Menu (<code>main_menu</code>): Returns to the wallet connected window.</li> <li>Connect Wallet (<code>connect_wallet</code>): Initiates the wallet connection process.</li> <li>Disconnect Wallet (<code>disconnect_wallet</code>): Initiates the wallet disconnection process.</li> <li>Cancel Transaction (<code>cancel_transaction</code>): Cancels any pending transactions and returns to the connected wallet window.</li> <li>Send Transaction (<code>send_transaction</code>): Initiates a single transaction and prompts the user to confirm.</li> <li>Send Batch Transaction (<code>send_batch_transaction</code>): Initiates multiple transactions in a batch and prompts the user to confirm.</li> </ul>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#running-the-bot","title":"Running the Bot","text":"<p>Finally, define the main entry point to start the bot.</p> <pre><code>async def main():\n    await dp.start_polling(bot)\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre> <ul> <li>Main Function: Starts polling to listen for incoming updates from Telegram.</li> <li>Entry Point: Ensures the bot starts when the script is executed directly.</li> </ul>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#complete-example","title":"Complete Example","text":"<p>For reference, here's the complete bot.py script integrating all the components discussed above.</p> <pre><code># bot.py\nimport base64\nfrom contextlib import suppress\nfrom typing import List\n\nfrom aiogram import Dispatcher, Bot\nfrom aiogram.client.default import DefaultBotProperties\nfrom aiogram.filters import CommandStart\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.fsm.storage.redis import RedisStorage\nfrom aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, Message, CallbackQuery\nfrom aiogram.utils.keyboard import InlineKeyboardBuilder\nfrom aiogram.utils.markdown import hide_link, hcode\nfrom redis.asyncio import Redis\n\nfrom storage import TCRedisStorage\nfrom tonutils.tonconnect import TonConnect\nfrom tonutils.tonconnect.models import WalletApp, Event, EventError, SendTransactionResponse\nfrom tonutils.tonconnect.utils.exceptions import TonConnectError, UserRejectsError, RequestTimeoutError\nfrom tonutils.wallet.data import TransferData\n\nBOT_TOKEN = \"your bot token\"\nREDIS_DSN = \"redis://localhost:6379\"\nTC_MANIFEST_URL = \"https://raw.githubusercontent.com/nessshon/tonutils/main/examples/tonconnect/tonconnect-manifest.json\"\n\nredis = Redis.from_url(url=REDIS_DSN)\ndp = Dispatcher(storage=RedisStorage(redis))\nbot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode=\"HTML\"))\ntc = TonConnect(storage=TCRedisStorage(redis), manifest_url=TC_MANIFEST_URL, wallets_fallback_file_path=\"./wallets.json\")\n\n\nasync def delete_last_message(user_id: int, message_id: int) -&gt; None:\n    state = dp.fsm.resolve_context(bot, user_id, user_id)\n    last_message_id = (await state.get_data()).get(\"last_message_id\")\n\n    if last_message_id is not None:\n        with suppress(Exception):\n            await bot.delete_message(chat_id=user_id, message_id=last_message_id)\n\n    await state.update_data(last_message_id=message_id)\n\n\ndef _connect_wallet_markup(\n        wallets: List[WalletApp],\n        selected_wallet: WalletApp,\n        connect_url: str,\n) -&gt; InlineKeyboardMarkup:\n    wallets_button = [\n        *[\n            InlineKeyboardButton(\n                text=f\"\u2022 {wallet.name} \u2022\" if wallet.app_name == selected_wallet.app_name else wallet.name,\n                callback_data=f\"app_wallet:{wallet.app_name}\",\n            ) for wallet in wallets\n        ]\n    ]\n    connect_wallet_button = InlineKeyboardButton(\n        text=f\"Connect {selected_wallet.name}\",\n        url=connect_url,\n    )\n    builder = InlineKeyboardBuilder()\n    builder.row(connect_wallet_button)\n    builder.row(*wallets_button, width=2)\n\n    return builder.as_markup()\n\n\ndef _confirm_transaction_markup(url: str, wallet_name: str) -&gt; InlineKeyboardMarkup:\n    return InlineKeyboardMarkup(\n        inline_keyboard=[\n            [InlineKeyboardButton(text=f\"Open {wallet_name}\", url=url)],\n            [InlineKeyboardButton(text=f\"Cancel\", callback_data=\"cancel_transaction\")],\n        ]\n    )\n\n\ndef _choose_action_markup() -&gt; InlineKeyboardMarkup:\n    builder = InlineKeyboardBuilder()\n    builder.row(InlineKeyboardButton(text=\"Send transaction\", callback_data=\"send_transaction\"))\n    builder.row(InlineKeyboardButton(text=\"Send batch transaction\", callback_data=\"send_batch_transaction\"))\n    builder.row(InlineKeyboardButton(text=\"Disconnect wallet\", callback_data=\"disconnect_wallet\"))\n\n    return builder.as_markup()\n\n\ndef _go_to_main_menu_markup() -&gt; InlineKeyboardMarkup:\n    builder = InlineKeyboardBuilder()\n    builder.row(InlineKeyboardButton(text=\"Main menu\", callback_data=\"main_menu\"))\n\n    return builder.as_markup()\n\n\nasync def connect_wallet_window(state: FSMContext, user_id: int) -&gt; None:\n    connector = await tc.init_connector(user_id)\n    state_data = await state.get_data()\n    wallets = await tc.get_wallets()\n\n    selected_wallet = state_data.get(\"selected_wallet\", wallets[0].app_name)\n    selected_wallet = next(w for w in wallets if w.app_name == selected_wallet)\n    connect_url = await connector.connect_wallet(wallet_app=selected_wallet)\n\n    qrcode_url = (\n        f\"https://qrcode.ness.su/create?\"\n        f\"box_size=20&amp;border=7&amp;image_padding=20\"\n        f\"&amp;data={base64.b64encode(connect_url.encode()).decode()}\"\n        f\"&amp;image_url={base64.b64encode(selected_wallet.image.encode()).decode()}\"\n    )\n\n    text = f\"{hide_link(qrcode_url)}Connect your wallet!\"\n    reply_markup = _connect_wallet_markup(wallets, selected_wallet, connect_url)\n\n    message = await bot.send_message(chat_id=user_id, text=text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n\n\nasync def wallet_connected_window(user_id: int) -&gt; None:\n    connector = await tc.init_connector(user_id)\n    wallet_address = connector.wallet.account.address.to_str(is_bounceable=False)\n\n    reply_markup = _choose_action_markup()\n    text = f\"Connected wallet:\\n{hcode(wallet_address)}\\n\\nChoose an action:\"\n\n    message = await bot.send_message(chat_id=user_id, text=text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n\n\nasync def send_transaction_window(user_id: int) -&gt; None:\n    connector = await tc.init_connector(user_id)\n    reply_markup = _confirm_transaction_markup(\n        url=connector.wallet_app.direct_url,\n        wallet_name=connector.wallet_app.name,\n    )\n\n    text = \"Please confirm the transaction in your wallet.\"\n\n    message = await bot.send_message(chat_id=user_id, text=text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n\n\nasync def transaction_sent_window(user_id: int, transaction: SendTransactionResponse) -&gt; None:\n    text = (\n        \"Transaction sent!\\n\\n\"\n        f\"Transaction msg hash:\\n{hcode(transaction.normalized_hash)}\\n\"\n        f\"Transaction BoC:\\n{hcode(transaction.boc)}\\n\"\n    )\n    reply_markup = _go_to_main_menu_markup()\n\n    message = await bot.send_message(chat_id=user_id, text=text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n\n\nasync def error_window(user_id: int, message_text: str, button_text: str, callback_data: str) -&gt; None:\n    builder = InlineKeyboardBuilder()\n    builder.row(InlineKeyboardButton(text=button_text, callback_data=callback_data))\n    reply_markup = builder.as_markup()\n\n    message = await bot.send_message(chat_id=user_id, text=message_text, reply_markup=reply_markup)\n    await delete_last_message(user_id, message.message_id)\n\n\n@tc.on_event(Event.CONNECT)\nasync def connect_event(user_id: int) -&gt; None:\n    await wallet_connected_window(user_id)\n\n\n@tc.on_event(EventError.CONNECT)\nasync def connect_error_event(error: TonConnectError, user_id: int) -&gt; None:\n    button_text, callback_data = \"Try again\", \"connect_wallet\"\n    if isinstance(error, UserRejectsError):\n        message_text = f\"You rejected the wallet connection.\"\n    elif isinstance(error, RequestTimeoutError):\n        message_text = f\"Connection request timed out.\"\n    else:\n        message_text = f\"Connection error. Error: {error.message}\"\n    await error_window(user_id, message_text, button_text, callback_data)\n\n\n@tc.on_event(Event.DISCONNECT)\nasync def disconnect_event(user_id: int) -&gt; None:\n    state = dp.fsm.resolve_context(bot, user_id, user_id)\n    await connect_wallet_window(state, user_id)\n\n\n@tc.on_event(EventError.DISCONNECT)\nasync def disconnect_error_event(error: TonConnectError, user_id: int) -&gt; None:\n    button_text, callback_data = \"Try again\", \"connect_wallet\"\n    if isinstance(error, UserRejectsError):\n        message_text = f\"You rejected the wallet disconnection.\"\n    elif isinstance(error, RequestTimeoutError):\n        message_text = f\"Disconnect request timed out.\"\n    else:\n        message_text = f\"Disconnect error. Error: {error.message}\"\n\n    await error_window(user_id, message_text, button_text, callback_data)\n\n\n@tc.on_event(Event.TRANSACTION)\nasync def transaction_event(user_id: int, transaction: SendTransactionResponse) -&gt; None:\n    await transaction_sent_window(user_id, transaction)\n\n\n@tc.on_event(EventError.TRANSACTION)\nasync def transaction_error_event(error: TonConnectError, user_id: int) -&gt; None:\n    button_text, callback_data = \"Try again\", \"main_menu\"\n    if isinstance(error, UserRejectsError):\n        message_text = f\"You rejected the transaction.\"\n    elif isinstance(error, RequestTimeoutError):\n        message_text = f\"Transaction request timed out.\"\n    else:\n        message_text = f\"Transaction error. Error: {error.message}\"\n\n    await error_window(user_id, message_text, button_text, callback_data)\n\n\n@dp.message(CommandStart())\nasync def start_command(message: Message, state: FSMContext) -&gt; None:\n    connector = await tc.init_connector(message.from_user.id)\n    rpc_request_id = (await state.get_data()).get(\"rpc_request_id\")\n    if connector.is_transaction_pending(rpc_request_id):\n        connector.cancel_pending_transaction(rpc_request_id)\n\n    if not connector.connected:\n        await connect_wallet_window(state, message.from_user.id)\n    else:\n        await wallet_connected_window(message.from_user.id)\n\n\n@dp.callback_query()\nasync def callback_query_handler(callback_query: CallbackQuery, state: FSMContext) -&gt; None:\n    connector = await tc.init_connector(callback_query.from_user.id)\n    rpc_request_id = (await state.get_data()).get(\"rpc_request_id\")\n\n    if callback_query.data.startswith(\"app_wallet:\"):\n        selected_wallet = callback_query.data.split(\":\")[1]\n        await state.update_data(selected_wallet=selected_wallet)\n        await connect_wallet_window(state, callback_query.from_user.id)\n\n    elif callback_query.data == \"main_menu\":\n        await wallet_connected_window(callback_query.from_user.id)\n\n    elif callback_query.data == \"connect_wallet\":\n        await connect_wallet_window(state, callback_query.from_user.id)\n\n    elif callback_query.data == \"disconnect_wallet\":\n        connector.add_event_kwargs(Event.DISCONNECT, state=state)\n        await connector.disconnect_wallet()\n\n    elif callback_query.data == \"cancel_transaction\":\n        if connector.is_transaction_pending(rpc_request_id):\n            connector.cancel_pending_transaction(rpc_request_id)\n        await wallet_connected_window(callback_query.from_user.id)\n\n    elif callback_query.data == \"send_transaction\":\n        rpc_request_id = await connector.send_transfer(\n            destination=connector.account.address,\n            amount=0.000000001,\n            body=\"Hello from tonutils!\",\n        )\n        await send_transaction_window(callback_query.from_user.id)\n        await state.update_data(rpc_request_id=rpc_request_id)\n\n    elif callback_query.data == \"send_batch_transaction\":\n        transfer_data = [\n            TransferData(\n                destination=connector.account.address,\n                amount=0.000000001,\n                body=\"Hello from tonutils!\",\n            ) for _ in range(4)\n        ]\n        rpc_request_id = await connector.send_batch_transfer(transfer_data)\n        await send_transaction_window(callback_query.from_user.id)\n        await state.update_data(rpc_request_id=rpc_request_id)\n\n    await callback_query.answer()\n\n\nasync def main():\n    await dp.start_polling(bot)\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"cookbook/ton-connect/telegram-bot-integration/#conclusion","title":"Conclusion","text":"<p>By following this cookbook, you can successfully integrate TonConnect into your Telegram Bot, enabling seamless wallet connections and transaction management.</p>"},{"location":"cookbook/ton-connect/wallet-connection/","title":"Wallet Connection","text":"<p>This guide provides concise instructions to integrate and manage wallet connections using the <code>TonConnect</code> from the <code>tonutils</code> library. Whether you're a beginner or an experienced developer, this cookbook will help you implement wallet connectivity efficiently.</p>"},{"location":"cookbook/ton-connect/wallet-connection/#installation","title":"Installation","text":"<p>Install the necessary Python packages using <code>pip</code>:</p> <pre><code>pip install tonutils aiofiles\n</code></pre>"},{"location":"cookbook/ton-connect/wallet-connection/#configuration","title":"Configuration","text":""},{"location":"cookbook/ton-connect/wallet-connection/#create-tonconnect-manifest","title":"Create TonConnect Manifest","text":"<p>Create a JSON file describing your application. This manifest is displayed in the wallet during connection.</p> <pre><code>{\n  \"url\": \"&lt;app-url&gt;\",                        // required\n  \"name\": \"&lt;app-name&gt;\",                      // required\n  \"iconUrl\": \"&lt;app-icon-url&gt;\",               // required\n  \"termsOfUseUrl\": \"&lt;terms-of-use-url&gt;\",     // optional\n  \"privacyPolicyUrl\": \"&lt;privacy-policy-url&gt;\" // optional\n}\n</code></pre> <p>Note</p> <p>Ensure this file is publicly accessible via its URL.</p>"},{"location":"cookbook/ton-connect/wallet-connection/#storage-implementation","title":"Storage Implementation","text":"<p>The <code>FileStorage</code> class manages persistent storage of connection data using a JSON file.</p> <pre><code>import json\nimport os\nfrom asyncio import Lock\nfrom typing import Optional, Dict\n\nimport aiofiles\n\nfrom tonutils.tonconnect import IStorage\n\n\nclass FileStorage(IStorage):\n\n    def __init__(self, file_path: str):\n        self.file_path = file_path\n        self.lock = Lock()\n\n        if not os.path.exists(self.file_path):\n            with open(self.file_path, 'w') as f:\n                json.dump({}, f)  # type: ignore\n\n    async def _read_data(self) -&gt; Dict[str, str]:\n        async with self.lock:\n            async with aiofiles.open(self.file_path, 'r') as f:\n                content = await f.read()\n                if content:\n                    return json.loads(content)\n                return {}\n\n    async def _write_data(self, data: Dict[str, str]) -&gt; None:\n        async with self.lock:\n            async with aiofiles.open(self.file_path, 'w') as f:\n                await f.write(json.dumps(data, indent=4))\n\n    async def set_item(self, key: str, value: str) -&gt; None:\n        data = await self._read_data()\n        data[key] = value\n        await self._write_data(data)\n\n    async def get_item(self, key: str, default_value: Optional[str] = None) -&gt; Optional[str]:\n        data = await self._read_data()\n        return data.get(key, default_value)\n\n    async def remove_item(self, key: str) -&gt; None:\n        data = await self._read_data()\n        if key in data:\n            del data[key]\n            await self._write_data(data)\n</code></pre>"},{"location":"cookbook/ton-connect/wallet-connection/#initialize-tonconnect","title":"Initialize TonConnect","text":"<p>Set up the TonConnect instance with the manifest URL and storage implementation.</p> <pre><code>from storage import FileStorage\n\nfrom tonutils.tonconnect import TonConnect\n\n# URL of the publicly hosted JSON manifest of the application\n# For detailed information: https://github.com/ton-blockchain/ton-connect/blob/main/requests-responses.md#app-manifest\nTC_MANIFEST_URL = \"https://raw.githubusercontent.com/nessshon/tonutils/main/examples/tonconnect/tonconnect-manifest.json\"\n\n# Initialize storage to save connected wallet data\n# In this example, FileStorage from storage.py is used\nTC_STORAGE = FileStorage(\"connection.json\")\n\n# Create an instance of TonConnect with the specified storage and manifest\ntc = TonConnect(storage=TC_STORAGE, manifest_url=TC_MANIFEST_URL, wallets_fallback_file_path=\"./wallets.json\")\n</code></pre>"},{"location":"cookbook/ton-connect/wallet-connection/#event-handling","title":"Event Handling","text":"<p>Handling events is essential for responding to wallet actions and errors. There are two primary methods to handle events: using decorators and using context managers.</p>"},{"location":"cookbook/ton-connect/wallet-connection/#using-decorators","title":"Using Decorators","text":"<p>Decorators associate event handlers with specific events. This method is straightforward and keeps your event handling logic organized.</p> <pre><code>@tc.on_event(Event.CONNECT)\nasync def on_wallet_connect(user_id: int, wallet: WalletInfo) -&gt; None:\n    wallet_address = wallet.account.address.to_str(is_bounceable=False)\n    print(f\"Wallet {wallet_address} connected to user {user_id}.\")\n</code></pre>"},{"location":"cookbook/ton-connect/wallet-connection/#using-context-managers","title":"Using Context Managers","text":"<p>Context managers provide a controlled environment for handling events, ensuring proper setup and teardown.</p> <pre><code>async with connector.connect_wallet_context() as response:\n    if isinstance(response, TonConnectError):\n        print(f\"Connection error: {response.message}\")\n    else:\n        print(f\"Connected wallet: {response.account.address.to_str(is_bounceable=False)}\")\n</code></pre>"},{"location":"cookbook/ton-connect/wallet-connection/#passing-additional-parameters","title":"Passing Additional Parameters","text":"<p>In some cases, you may want to provide custom data or context to your event handlers \u2014 for example, adding tags, notes, or extra flags.</p> <p>You can achieve this by using the <code>connector.add_event_kwargs</code> method, which attaches additional keyword arguments that will be passed into the handler alongside the default parameters.</p> <p>Step 1: Add Custom Parameters</p> <p>Call <code>add_event_kwargs</code> before triggering or waiting on an event:</p> <pre><code>connector.add_event_kwargs(\n    event=Event.CONNECT,\n    comment=\"Hello from tonutils!\",\n)\n</code></pre> <p>Step 2: Update the Event Handler to Receive Them</p> <p>Define the handler to accept these extra parameters:</p> <pre><code>@tc.on_event(Event.CONNECT)\nasync def on_wallet_connect(user_id: int, wallet: WalletInfo, comment: str) -&gt; None:\n    print(f\"Comment: {comment}\")\n</code></pre> <p>Key Points:</p> <ul> <li>You can attach multiple parameters (any keyword argument).</li> <li>The handler function must include matching parameter names.</li> <li>This mechanism works for all supported events (<code>CONNECT</code>, <code>DISCONNECT</code>, <code>TRANSACTION</code>, etc.).</li> </ul>"},{"location":"cookbook/ton-connect/wallet-connection/#complete-example","title":"Complete Example","text":"<p>Below is an example demonstrating connector initialization, event handling, and wallet management.</p> <pre><code>import asyncio\n\nfrom storage import FileStorage\n\nfrom tonutils.tonconnect import TonConnect\nfrom tonutils.tonconnect.models import Event, EventError, WalletInfo\nfrom tonutils.tonconnect.utils.exceptions import TonConnectError, UserRejectsError, RequestTimeoutError\n\n# URL of the publicly hosted JSON manifest of the application\n# For detailed information: https://github.com/ton-blockchain/ton-connect/blob/main/requests-responses.md#app-manifest\nTC_MANIFEST_URL = \"https://raw.githubusercontent.com/nessshon/tonutils/main/examples/tonconnect/tonconnect-manifest.json\"\n\n# Initialize storage to save connected wallet data\n# In this example, FileStorage from storage.py is used\nTC_STORAGE = FileStorage(\"connection.json\")\n\n# Create an instance of TonConnect with the specified storage and manifest\ntc = TonConnect(storage=TC_STORAGE, manifest_url=TC_MANIFEST_URL, wallets_fallback_file_path=\"./wallets.json\")\n\n\n@tc.on_event(Event.CONNECT)\nasync def on_wallet_connect(user_id: int, wallet: WalletInfo) -&gt; None:\n    \"\"\"\n    Handler for successful wallet connection events.\n    Processes all successful wallet connections and performs necessary actions.\n\n    Available handler parameters:\n    - user_id (int): User identifier\n    - wallet (WalletInfo): Wallet information\n    - Additional parameters can be passed using `connector.add_event_kwargs()`\n      Example: `connector.add_event_kwargs(event=Event.CONNECT, comment=\"Hello from tonutils!\")`\n      In this example, `comment` is an additional parameter that will be passed to the handler.\n\n    Wallet details can be obtained from the following attributes:\n    - wallet.account (Account): Information about an account with an address, chain/network,\n                                wallet state_init, and optional public key information.\n    - wallet.ton_proof (TonProof): Verification details such as timestamp, domain information,\n                                   payload, and a signature.\n    - wallet.device (DeviceInfo): Information about a device associated with a wallet.\n    \"\"\"\n    wallet_address = wallet.account.address.to_str(is_bounceable=False)\n    print(f\"Wallet {wallet_address} connected to user {user_id}.\")\n\n\n@tc.on_event(EventError.CONNECT)\nasync def on_wallet_connect_error(user_id: int, error: TonConnectError) -&gt; None:\n    \"\"\"\n    Handler for connection error events.\n    Processes all errors that occur when connecting wallets.\n\n    Available handler parameters:\n    - user_id (int): User identifier\n    - error (TonConnectError): Error information\n    - Additional parameters can be passed using `connector.add_event_kwargs()`\n      Example: `connector.add_event_kwargs(event=Event.CONNECT, comment=\"Hello from tonutils!\")`\n      In this example, `comment` is an additional parameter that will be passed to the handler.\n\n    The type of error can be determined using isinstance:\n    - UserRejectsError: User rejected the wallet connection.\n    - RequestTimeoutError: Wallet connection timed out.\n    \"\"\"\n    if isinstance(error, UserRejectsError):\n        print(f\"User {user_id} rejected the wallet connection.\")\n    elif isinstance(error, RequestTimeoutError):\n        print(f\"Connection request timed out for user {user_id}.\")\n    else:\n        print(f\"Connection error for user {user_id}: {error.message}\")\n\n\n@tc.on_event(Event.DISCONNECT)\nasync def on_wallet_disconnect(user_id: int, wallet: WalletInfo) -&gt; None:\n    \"\"\"\n    Handler for disconnected wallet events.\n    Processes all successful wallet disconnections and performs necessary actions.\n\n    Available handler parameters:\n    - user_id (int): User identifier\n    - wallet (WalletInfo): Wallet information\n    - Additional parameters can be passed using `connector.add_event_kwargs()`\n      Example: `connector.add_event_kwargs(event=Event.DISCONNECT, comment=\"Hello from tonutils!\")`\n      In this example, `comment` is an additional parameter that will be passed to the handler.\n    \"\"\"\n    wallet_address = wallet.account.address.to_str(is_bounceable=False)\n    print(f\"Wallet {wallet_address} disconnected from user {user_id}.\")\n\n\n@tc.on_event(EventError.DISCONNECT)\nasync def on_wallet_disconnect_error(user_id: int, error: TonConnectError) -&gt; None:\n    \"\"\"\n    Handler for disconnected wallet events.\n    Processes all successful wallet disconnections and performs necessary actions.\n\n    Available handler parameters:\n    - user_id (int): User identifier\n    - error (TonConnectError): Error information\n    - Additional parameters can be passed using `connector.add_event_kwargs()`\n      Example: `connector.add_event_kwargs(event=Event.DISCONNECT, comment=\"Hello from tonutils!\")`\n      In this example, `comment` is an additional parameter that will be passed to the handler.\n    \"\"\"\n    if isinstance(error, RequestTimeoutError):\n        print(f\"Disconnect request timed out for user {user_id}.\")\n    else:\n        print(f\"Disconnect error for user {user_id}: {error.message}\")\n\n\nasync def main() -&gt; None:\n    user_id = 12345  # Example user ID\n\n    # Initialize the connector for the user\n    connector = await tc.init_connector(user_id)\n\n    if not connector.connected:\n        wallets = await tc.get_wallets()\n        selected_wallet = wallets[1]  # Example: Tonkeeper\n        connect_url = await connector.connect_wallet(selected_wallet)\n        print(f\"Connect your wallet here:\\n{connect_url}\")\n\n        # Add additional parameters to event handlers\n        connector.add_event_kwargs(event=Event.TRANSACTION, some_param=\"foo\")\n\n        print(\"Waiting for wallet connection...\")\n        async with connector.connect_wallet_context() as response:\n            if isinstance(response, TonConnectError):\n                print(f\"Connection error: {response.message}\")\n            else:\n                print(f\"Connected wallet: {response.account.address.to_str(is_bounceable=False)}\")\n    else:\n        wallet_address = connector.account.address.to_str(is_bounceable=False)\n        print(f\"Wallet already connected: {wallet_address}\")\n\n        user_input = input(\"Do you want to disconnect the wallet? (y/n): \").strip().lower()\n        if user_input == 'y':\n            await connector.disconnect_wallet()\n            print(\"Wallet successfully disconnected.\")\n        else:\n            print(\"Wallet remains connected.\")\n\n    await tc.close_all()\n\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.run(main())\n    except (KeyboardInterrupt, SystemExit):\n        asyncio.run(tc.close_all())\n</code></pre>"},{"location":"cookbook/ton-connect/wallet-connection/#ton-proof-example","title":"Ton Proof Example","text":"<p>To confirm ownership of a wallet, use Ton Proof to validate signed payloads.</p> <pre><code>from storage import FileStorage\nfrom tonutils.tonconnect import TonConnect\nfrom tonutils.tonconnect.utils.exceptions import TonConnectError\nfrom tonutils.tonconnect.utils.proof import generate_proof_payload, verify_proof_payload\n\n# URL of the publicly hosted JSON manifest of the application\n# For detailed information: https://github.com/ton-blockchain/ton-connect/blob/main/requests-responses.md#app-manifest\nTC_MANIFEST_URL = \"https://raw.githubusercontent.com/nessshon/tonutils/main/examples/tonconnect/tonconnect-manifest.json\"\n\n# Initialize storage to save connected wallet data\n# In this example, FileStorage from storage.py is used\nTC_STORAGE = FileStorage(\"connection.json\")\n\n# Create an instance of TonConnect with the specified storage and manifest\ntc = TonConnect(storage=TC_STORAGE, manifest_url=TC_MANIFEST_URL, wallets_fallback_file_path=\"./wallets.json\")\n\n\nasync def main() -&gt; None:\n    user_id = 1  # Example user ID\n\n    # Initialize the connector for the user\n    connector = await tc.init_connector(user_id)\n\n    # Generate the proof payload\n    proof_payload = generate_proof_payload()\n\n    # Check if the wallet is already connected\n    if not connector.connected:\n        # Get all available wallets\n        wallets = await tc.get_wallets()\n\n        # As an example, we will select the wallet with index 1 (Tonkeeper)\n        selected_wallet = wallets[1]\n        connect_url = await connector.connect_wallet(selected_wallet, ton_proof=proof_payload)\n        print(f\"Please connect your wallet by visiting the following URL:\\n{connect_url}\")\n\n        print(\"Waiting for wallet connection...\")\n        async with connector.connect_wallet_context() as response:\n            if isinstance(response, TonConnectError):\n                print(f\"Connection error: {response.message}\")\n            else:\n                if verify_proof_payload(proof_payload, connector.wallet):\n                    print(f\"Connected wallet: {response.account.address.to_str(is_bounceable=False)}\")\n                else:\n                    await connector.disconnect_wallet()\n                    print(\"Proof verification failed.\")\n\n    else:\n        wallet_address = connector.account.address.to_str(is_bounceable=False)\n        print(f\"Wallet already connected: {wallet_address}\")\n\n        # Prompt the user to disconnect the wallet\n        user_input = input(\"Do you want to disconnect the wallet? (y/n): \").strip().lower()\n\n        if user_input == 'y':\n            # Disconnect the wallet\n            await connector.disconnect_wallet()\n            print(\"Wallet successfully disconnected.\")\n        else:\n            print(\"Wallet remains connected.\")\n\n    # Close all TonConnect connections\n    await tc.close_all()\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    try:\n        asyncio.run(main())\n    except (KeyboardInterrupt, SystemExit):\n        # Ensure all connections are closed in case of interruption\n        asyncio.run(tc.close_all())\n</code></pre>"},{"location":"cookbook/ton-connect/wallet-connection/#conclusion","title":"Conclusion","text":"<p>By following this cookbook, you can successfully integrate TonConnect into your script enabling seamless wallet connections.</p>"},{"location":"guide/getting-testnet-assets/","title":"Getting testnet assets","text":"<p>This section explains how to claim testnet assets.</p>"},{"location":"guide/getting-testnet-assets/#ton","title":"TON","text":"TON To get TON, go to the Telegram bot and follow its instructions. Open Telegram Bot"},{"location":"guide/getting-testnet-assets/#not-jetton-9-decimals","title":"NOT Jetton (9 decimals)","text":"NOT Jetton To claim NOT jettons, scan this QR code in your TON wallet. Claim Testnet NOT"},{"location":"guide/getting-testnet-assets/#usd-jetton-6-decimals","title":"USD\u20ae Jetton (6 decimals)","text":"USD\u20ae Jetton To claim USD\u20ae jettons, scan this QR code in your TON wallet. Claim Testnet USD\u20ae"},{"location":"guide/installation-and-initialization/","title":"Installation and Initialization","text":"<p>This section explains how to install the <code>tonutils</code> library and select the appropriate client depending on your needs.</p>"},{"location":"guide/installation-and-initialization/#installation","title":"Installation","text":"<p>To install the base <code>tonutils</code> package:</p> <pre><code>pip install tonutils\n</code></pre> <p>If you need to use Native ADNL connections, install with optional dependencies:</p> <pre><code>pip install 'tonutils[pytoniq]'\n</code></pre>"},{"location":"guide/installation-and-initialization/#available-clients","title":"Available Clients","text":""},{"location":"guide/installation-and-initialization/#rpc-api","title":"RPC API","text":""},{"location":"guide/installation-and-initialization/#toncenter","title":"toncenter","text":"<p>toncenter.com \u2014 fast and reliable HTTP API for The Open Network.  </p> <p>Note</p> <p>API key is optional, but for better performance it is recommended to obtain one via  @tonapibot.</p> <pre><code>from tonutils.client import ToncenterV2Client\nfrom tonutils.client import ToncenterV3Client\n\nAPI_KEY = \"your api key\"  # Optional\nIS_TESTNET = True\n\n# Using Toncenter V3 client\nclient_v3 = ToncenterV3Client(api_key=API_KEY, is_testnet=IS_TESTNET)\n\n# Using Toncenter V2 client (if needed)\n# client_v2 = ToncenterV2Client(api_key=API_KEY, is_testnet=IS_TESTNET)\n</code></pre>"},{"location":"guide/installation-and-initialization/#tonapi","title":"tonapi","text":"<p>tonapi.io \u2014 REST API to the TON blockchain explorer.  </p> <p>Note</p> <p>Requires an API key from tonconsole.com.</p> <pre><code>from tonutils.client import TonapiClient\n\nAPI_KEY = \"your api key\"\nIS_TESTNET = True\nclient = TonapiClient(api_key=API_KEY, is_testnet=IS_TESTNET)\n</code></pre>"},{"location":"guide/installation-and-initialization/#quicknode","title":"quicknode","text":"<p>quicknode.com \u2014 low-latency HTTP API access to TON via global infrastructure.  </p> <p>Note</p> <p>Does not support testnet!</p> <p>Note</p> <p>Requires an API URL from quicknode.com.</p> <pre><code>from tonutils.client import QuicknodeClient\n\nHTTP_PROVIDER_URL = \"https://blissful-withered-surf.ton-mainnet.quiknode.pro/d6e8...1964\"\nclient = QuicknodeClient(HTTP_PROVIDER_URL)\n</code></pre>"},{"location":"guide/installation-and-initialization/#tatum","title":"tatum","text":"<p>tatum.io \u2014 RPCs and APIs powering Web3.  </p> <p>Note</p> <p>Requires an API key from tatum.io.</p> <pre><code>from tonutils.client import TatumClient\n\nAPI_KEY = \"your api key\"\nIS_TESTNET = True\nclient = TatumClient(api_key=API_KEY, is_testnet=IS_TESTNET)\n</code></pre>"},{"location":"guide/installation-and-initialization/#native-adnl","title":"Native ADNL","text":""},{"location":"guide/installation-and-initialization/#pytoniq","title":"pytoniq","text":"<p>pytoniq \u2014 library for direct interaction with Lite servers.  </p> <p>Note</p> <p>For better performance, provide your own config, which can be obtained from the liteserver bot.</p> <pre><code>from tonutils.client import LiteserverClient\n\nIS_TESTNET = True\nclient = LiteserverClient(is_testnet=IS_TESTNET)\n\n# Using custom configuration\n# config = {}  # Your LiteServer config here \n# client = LiteserverClient(config=config)\n</code></pre>"},{"location":"guide/wallet-operations/","title":"Wallet Operations","text":"<p>This section provides a complete guide to managing wallets using the <code>tonutils</code> library. It covers key operations such as:</p> <ul> <li>Creating and deploying wallets</li> <li>Importing wallets from mnemonic or private key</li> <li>Sending transactions (TON, NFTs, Jettons)</li> <li>Performing batch transfers</li> <li>Executing Jetton swaps (via STON.fi and DeDus.io)</li> </ul>"},{"location":"guide/wallet-operations/#supported-wallet","title":"Supported Wallet","text":"<p>The library supports multiple wallet versions and types:</p> <ul> <li>Standard wallets:   <code>WalletV2R1</code>, <code>WalletV2R2</code>, <code>WalletV3R1</code>, <code>WalletV3R2</code>, <code>WalletV4R1</code>, <code>WalletV4R2</code>, <code>WalletV5R1</code></li> <li>Highload wallets (for services and exchanges):   <code>HighloadWalletV2</code>, <code>HighloadWalletV3</code></li> <li>Preprocessed wallets (for economical batch operations):   <code>PreprocessedWalletV2</code>, <code>PreprocessedWalletV2R1</code></li> </ul>"},{"location":"guide/wallet-operations/#recommendations","title":"Recommendations","text":"<ul> <li>For general use, it\u2019s recommended to work with wallet versions v3r2 to v5r1, preferably v5r1 for full feature support.</li> <li>For service and exchange integrations, use HighloadWalletV3.</li> <li>For large-scale batch transfers where gas optimization is critical, use PreprocessedWallet types.</li> </ul>"},{"location":"guide/wallet-operations/#create-wallet","title":"Create Wallet","text":"<p>To create a new wallet, use the <code>.create()</code> method provided by the wallet class you select. This generates a wallet instance along with its public key, private key, and mnemonic phrase.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import (\n    # Uncomment the following lines to use different wallet versions:\n    # WalletV2R1,\n    # WalletV2R2,\n    # WalletV3R1,\n    # WalletV3R2,\n    # WalletV4R1,\n    WalletV4R2,\n    # WalletV5R1,\n    # HighloadWalletV2,\n    # HighloadWalletV3,\n    # PreprocessedWalletV2,\n    # PreprocessedWalletV2R1,\n)\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n\ndef main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.create(client)\n\n    # Uncomment and use the following lines to create different wallet versions:\n    # wallet, public_key, private_key, mnemonic = WalletV3R2.create(client)\n    # wallet, public_key, private_key, mnemonic = WalletV4R1.create(client)\n    # wallet, public_key, private_key, mnemonic = WalletV4R2.create(client)\n    # wallet, public_key, private_key, mnemonic = WalletV5R1.create(client)\n    # wallet, public_key, private_key, mnemonic = HighloadWalletV2.create(client)\n    # wallet, public_key, private_key, mnemonic = HighloadWalletV3.create(client)\n    # wallet, public_key, private_key, mnemonic = PreprocessedWalletV2.create(client)\n    # wallet, public_key, private_key, mnemonic = PreprocessedWalletV2R1.create(client)\n\n    print(\"Wallet has been successfully created!\")\n    print(f\"Address: {wallet.address.to_str()}\")\n    print(f\"Mnemonic: {mnemonic}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"guide/wallet-operations/#import-wallet","title":"Import Wallet","text":"<p>You can import a wallet either from a mnemonic phrase or directly from a private key.</p>"},{"location":"guide/wallet-operations/#from-mnemonic","title":"From Mnemonic","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\ndef main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    print(f\"Wallet address: {wallet.address.to_str()}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"guide/wallet-operations/#from-private-key","title":"From Private Key","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Private key (32 or 64 bytes)\nPRIVATE_KEY: bytes = b\"your_private_key_bytes\"\n\n\ndef main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet = WalletV4R2.from_private_key(client, PRIVATE_KEY)\n\n    print(f\"Wallet address: {wallet.address.to_str()}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"guide/wallet-operations/#deploy-wallet","title":"Deploy Wallet","text":"<p>To deploy a wallet, reconstruct it from a mnemonic and call the <code>.deploy()</code> method. This will publish the wallet contract on-chain.</p> <pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import (\n    # Uncomment the following lines to use different wallet versions:\n    # WalletV2R1,\n    # WalletV2R2,\n    # WalletV3R1,\n    # WalletV3R2,\n    # WalletV4R1,\n    WalletV4R2,\n    # WalletV5R1,\n    # HighloadWalletV2,\n    # HighloadWalletV3,\n    # PreprocessedWalletV2,\n    # PreprocessedWalletV2R1,\n)\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    # Uncomment and use the following lines to create different wallet versions from mnemonic:\n    # wallet, public_key, private_key, mnemonic = WalletV2R1.from_mnemonic(client, MNEMONIC)\n    # wallet, public_key, private_key, mnemonic = WalletV2R2.from_mnemonic(client, MNEMONIC)\n    # wallet, public_key, private_key, mnemonic = WalletV3R2.from_mnemonic(client, MNEMONIC)\n    # wallet, public_key, private_key, mnemonic = WalletV4R1.from_mnemonic(client, MNEMONIC)\n    # wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC)\n    # wallet, public_key, private_key, mnemonic = WalletV5R1.from_mnemonic(client, MNEMONIC)\n    # wallet, public_key, private_key, mnemonic = HighloadWalletV2.from_mnemonic(client, MNEMONIC)\n    # wallet, public_key, private_key, mnemonic = HighloadWalletV3.from_mnemonic(client, MNEMONIC)\n    # wallet, public_key, private_key, mnemonic = PreprocessedWalletV2.from_mnemonic(client, MNEMONIC)\n    # wallet, public_key, private_key, mnemonic = PreprocessedWalletV2R1.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.deploy()\n\n    print(f\"Wallet deployed successfully!\")\n    print(f\"Wallet address: {wallet.address.to_str()}\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#transfers","title":"Transfers","text":""},{"location":"guide/wallet-operations/#send-ton","title":"Send TON","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the recipient\nDESTINATION_ADDRESS = \"UQ...\"\n\n# Optional comment to include in the forward payload\nCOMMENT = \"Hello from tonutils!\"\n\n# Amount to transfer in TON\nAMOUNT = 0.01\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.transfer(\n        destination=DESTINATION_ADDRESS,\n        amount=AMOUNT,\n        body=COMMENT,\n    )\n\n    print(f\"Successfully transferred {AMOUNT} TON!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#send-nft","title":"Send NFT","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the NFT to be transferred and the new owner address\nNFT_ADDRESS = \"EQ...\"\nNEW_OWNER_ADDRESS = \"UQ...\"\n\n# Optional comment to include in the forward payload\nCOMMENT = \"Hello from tonutils!\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.transfer_nft(\n        destination=NEW_OWNER_ADDRESS,\n        nft_address=NFT_ADDRESS,\n        forward_payload=COMMENT,\n    )\n\n    print(\"Successfully transferred!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#send-jetton","title":"Send Jetton","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for the test network, False for the main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# The address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# Number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n# Amount of Jettons to transfer (in base units, considering decimals)\nJETTON_AMOUNT = 0.01\n\n# The address of the recipient\nDESTINATION_ADDRESS = \"UQ...\"\n\n# Comment to include in the transfer payload\nCOMMENT = \"Hello from tonutils!\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.transfer_jetton(\n        destination=DESTINATION_ADDRESS,\n        jetton_master_address=JETTON_MASTER_ADDRESS,\n        jetton_amount=JETTON_AMOUNT,\n        jetton_decimals=JETTON_DECIMALS,\n        forward_payload=COMMENT,\n    )\n\n    print(f\"Successfully transferred {JETTON_AMOUNT} jettons!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#batch-transfers","title":"Batch Transfers","text":""},{"location":"guide/wallet-operations/#batch-send-ton","title":"Batch Send TON","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import TransferData\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.batch_transfer(\n        data_list=[\n            TransferData(\n                destination=\"UQ...\",\n                amount=0.01,\n                body=\"Hello from tonutils!\",\n            ),\n            TransferData(\n                destination=\"UQ...\",\n                amount=0.01,\n                body=\"Hello from tonutils!\",\n            ),\n            TransferData(\n                destination=\"UQ...\",\n                amount=0.01,\n                body=\"Hello from tonutils!\",\n            ),\n            TransferData(\n                destination=\"UQ...\",\n                amount=0.01,\n                body=\"Hello from tonutils!\",\n            ),\n        ]\n    )\n\n    print(\"Successfully transferred!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#batch-send-nft","title":"Batch Send NFT","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import TransferNFTData\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.batch_nft_transfer(\n        data_list=[\n            TransferNFTData(\n                destination=\"UQ...\",\n                nft_address=\"EQ..\",\n                forward_payload=\"Hello from tonutils!\",\n            ),\n            TransferNFTData(\n                destination=\"UQ...\",\n                nft_address=\"EQ..\",\n                forward_payload=\"Hello from tonutils!\",\n            ),\n            TransferNFTData(\n                destination=\"UQ...\",\n                nft_address=\"EQ..\",\n                forward_payload=\"Hello from tonutils!\",\n            ),\n            TransferNFTData(\n                destination=\"UQ...\",\n                nft_address=\"EQ..\",\n                forward_payload=\"Hello from tonutils!\",\n            )\n        ]\n    )\n\n    print(\"Successfully transferred!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#batch-send-jetton","title":"Batch Send Jetton","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import TransferJettonData\n\n# Set to True for test network, False for main network\nIS_TESTNET = True\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, public_key, private_key, mnemonic = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.batch_jetton_transfer(\n        data_list=[\n            TransferJettonData(\n                destination=\"UQ...\",\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n                forward_payload=\"Hello from tonutils!\",\n            ),\n            TransferJettonData(\n                destination=\"UQ...\",\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n                forward_payload=\"Hello from tonutils!\",\n            ),\n            TransferJettonData(\n                destination=\"UQ...\",\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n                forward_payload=\"Hello from tonutils!\",\n            ),\n            TransferJettonData(\n                destination=\"UQ...\",\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n                forward_payload=\"Hello from tonutils!\",\n            ),\n        ]\n    )\n\n    print(\"Successfully transferred!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#jetton-swaps","title":"Jetton Swaps","text":""},{"location":"guide/wallet-operations/#using-stonfi","title":"Using STON.fi","text":""},{"location":"guide/wallet-operations/#swap-ton-jetton","title":"Swap TON \u2192 Jetton","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for the test network, False for the main network\nIS_TESTNET = False\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the Jetton Master for swapping (TON &gt; USD\u20ae)\nTO_JETTON_MASTER_ADDRESS = \"EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs\"  # noqa\n\n# Number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n# Amount of TON to swap (in TON)\nSWAP_TON_AMOUNT = 1\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.stonfi_swap_ton_to_jetton(\n        jetton_master_address=TO_JETTON_MASTER_ADDRESS,\n        ton_amount=SWAP_TON_AMOUNT,\n        jetton_decimals=JETTON_DECIMALS,\n    )\n\n    print(\"Successfully swapped TON to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#swap-jetton-ton","title":"Swap Jetton \u2192 TON","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for the test network, False for the main network\nIS_TESTNET = False\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the Jetton Master for swapping (TON &gt; USD\u20ae)\nTO_JETTON_MASTER_ADDRESS = \"EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs\"  # noqa\n\n# Number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n# Amount of Jettons to swap (in base units, considering decimals)\nJETTON_AMOUNT = 1\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.stonfi_swap_jetton_to_ton(\n        jetton_master_address=TO_JETTON_MASTER_ADDRESS,\n        jetton_amount=JETTON_AMOUNT,\n        jetton_decimals=JETTON_DECIMALS,\n    )\n\n    print(\"Successfully swapped Jetton to TON!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#swap-jetton-jetton","title":"Swap Jetton \u2192 Jetton","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for the test network, False for the main network\nIS_TESTNET = False\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Addresses of the Jetton Masters for swapping\nFROM_JETTON_MASTER_ADDRESS = \"EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs\"  # noqa\nTO_JETTON_MASTER_ADDRESS = \"EQAvlWFDxGF2lXm67y4yzC17wYKD9A0guwPkMs1gOsM__NOT\"  # noqa\n\n# Number of decimal places for the Jetton\nFROM_JETTON_DECIMALS = 6\nTO_JETTON_DECIMALS = 9\n\n# Amount of Jettons to swap (in base units, considering decimals)\nJETTON_AMOUNT = 1\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.stonfi_swap_jetton_to_jetton(\n        from_jetton_master_address=FROM_JETTON_MASTER_ADDRESS,\n        to_jetton_master_address=TO_JETTON_MASTER_ADDRESS,\n        jetton_amount=JETTON_AMOUNT,\n        from_jetton_decimals=FROM_JETTON_DECIMALS,\n        to_jetton_decimals=TO_JETTON_DECIMALS,\n    )\n\n    print(\"Successfully swapped Jetton to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#batch-swap-ton-jetton","title":"Batch Swap TON \u2192 Jetton","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import StonfiSwapTONToJettonData\n\n# Set to True for the test network, False for the main network\nIS_TESTNET = False\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.batch_stonfi_swap_ton_to_jetton(\n        data_list=[\n            StonfiSwapTONToJettonData(\n                jetton_master_address=\"EQ...\",\n                ton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            StonfiSwapTONToJettonData(\n                jetton_master_address=\"EQ...\",\n                ton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            StonfiSwapTONToJettonData(\n                jetton_master_address=\"EQ...\",\n                ton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            StonfiSwapTONToJettonData(\n                jetton_master_address=\"EQ...\",\n                ton_amount=0.01,\n                jetton_decimals=9,\n            ),\n        ],\n    )\n\n    print(\"Successfully swapped TON to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#batch-swap-jetton-ton","title":"Batch Swap Jetton \u2192 TON","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import StonfiSwapJettonToTONData\n\n# Set to True for the test network, False for the main network\nIS_TESTNET = False\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client(is_testnet=IS_TESTNET)\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.batch_stonfi_swap_jetton_to_ton(\n        data_list=[\n            StonfiSwapJettonToTONData(\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            StonfiSwapJettonToTONData(\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            StonfiSwapJettonToTONData(\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            StonfiSwapJettonToTONData(\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n            ),\n        ],\n    )\n\n    print(\"Successfully swapped TON to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#batch-swap-jetton-jetton","title":"Batch Swap Jetton \u2192 Jetton","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import StonfiSwapJettonToJettonData\n\n# Set to True for the test network, False for the main network\nIS_TESTNET = False\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.batch_stonfi_swap_jetton_to_jetton(\n        data_list=[\n            StonfiSwapJettonToJettonData(\n                from_jetton_master_address=\"EQ...\",\n                to_jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                from_jetton_decimals=9,\n                to_jetton_decimals=9,\n            ),\n            StonfiSwapJettonToJettonData(\n                from_jetton_master_address=\"EQ...\",\n                to_jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                from_jetton_decimals=9,\n                to_jetton_decimals=9,\n            ),\n            StonfiSwapJettonToJettonData(\n                from_jetton_master_address=\"EQ...\",\n                to_jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                from_jetton_decimals=9,\n                to_jetton_decimals=9,\n            ),\n            StonfiSwapJettonToJettonData(\n                from_jetton_master_address=\"EQ...\",\n                to_jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                from_jetton_decimals=9,\n                to_jetton_decimals=9,\n            ),\n        ],\n    )\n\n    print(\"Successfully swapped TON to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#using-dedusio","title":"Using DeDus.io","text":""},{"location":"guide/wallet-operations/#swap-ton-jetton_1","title":"Swap TON \u2192 Jetton","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# Number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n# Amount of TON to swap (in TON)\nSWAP_TON_AMOUNT = 1\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.dedust_swap_ton_to_jetton(\n        jetton_master_address=JETTON_MASTER_ADDRESS,\n        ton_amount=SWAP_TON_AMOUNT,\n        jetton_decimals=JETTON_DECIMALS,\n    )\n\n    print(\"Successfully swapped TON to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#swap-jetton-ton_1","title":"Swap Jetton \u2192 TON","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Address of the Jetton Master contract\nJETTON_MASTER_ADDRESS = \"EQ...\"\n\n# Number of decimal places for the Jetton\nJETTON_DECIMALS = 9\n\n# Amount of Jettons to swap (in base units, considering decimals)\nJETTON_AMOUNT = 1\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.dedust_swap_jetton_to_ton(\n        jetton_master_address=JETTON_MASTER_ADDRESS,\n        jetton_amount=JETTON_AMOUNT,\n        jetton_decimals=JETTON_DECIMALS,\n    )\n\n    print(\"Successfully swapped Jetton to TON!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#swap-jetton-jetton_1","title":"Swap Jetton \u2192 Jetton","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n# Addresses of the Jetton Masters for swapping\nFROM_JETTON_MASTER_ADDRESS = \"EQ...\"\nTO_JETTON_MASTER_B_ADDRESS = \"EQ...\"\n\n# Number of decimal places for the Jetton\nFROM_JETTON_DECIMALS = 9\nTO_JETTON_DECIMALS = 9\n\n# Amount of Jettons to swap (in base units, considering decimals)\nJETTON_AMOUNT = 1\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.dedust_swap_jetton_to_jetton(\n        from_jetton_master_address=FROM_JETTON_MASTER_ADDRESS,\n        to_jetton_master_address=TO_JETTON_MASTER_B_ADDRESS,\n        jetton_amount=JETTON_AMOUNT,\n        from_jetton_decimals=FROM_JETTON_DECIMALS,\n        to_jetton_decimals=TO_JETTON_DECIMALS,\n    )\n\n    print(\"Successfully swapped Jetton to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#batch-swap-ton-jetton_1","title":"Batch Swap TON \u2192 Jetton","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import DedustSwapTONToJettonData\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.batch_dedust_swap_ton_to_jetton(\n        data_list=[\n            DedustSwapTONToJettonData(\n                jetton_master_address=\"EQ...\",\n                ton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            DedustSwapTONToJettonData(\n                jetton_master_address=\"EQ...\",\n                ton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            DedustSwapTONToJettonData(\n                jetton_master_address=\"EQ...\",\n                ton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            DedustSwapTONToJettonData(\n                jetton_master_address=\"EQ...\",\n                ton_amount=0.01,\n                jetton_decimals=9,\n            ),\n        ]\n    )\n\n    print(\"Successfully swapped TON to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#batch-swap-jetton-ton_1","title":"Batch Swap Jetton \u2192 TON","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import DedustSwapJettonToTONData\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.batch_dedust_swap_jetton_to_ton(\n        data_list=[\n            DedustSwapJettonToTONData(\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            DedustSwapJettonToTONData(\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            DedustSwapJettonToTONData(\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n            ),\n            DedustSwapJettonToTONData(\n                jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                jetton_decimals=9,\n            ),\n        ]\n    )\n\n    print(\"Successfully swapped TON to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/wallet-operations/#batch-swap-jetton-jetton_1","title":"Batch Swap Jetton \u2192 Jetton","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import DedustSwapJettonToJettonData\n\n# Mnemonic phrase\nMNEMONIC = \"word1 word2 word3 ...\"\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n    tx_hash = await wallet.batch_dedust_swap_jetton_to_jetton(\n        data_list=[\n            DedustSwapJettonToJettonData(\n                from_jetton_master_address=\"EQ...\",\n                to_jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                from_jetton_decimals=9,\n                to_jetton_decimals=9,\n            ),\n            DedustSwapJettonToJettonData(\n                from_jetton_master_address=\"EQ...\",\n                to_jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                from_jetton_decimals=9,\n                to_jetton_decimals=9,\n            ),\n            DedustSwapJettonToJettonData(\n                from_jetton_master_address=\"EQ...\",\n                to_jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                from_jetton_decimals=9,\n                to_jetton_decimals=9,\n            ),\n            DedustSwapJettonToJettonData(\n                from_jetton_master_address=\"EQ...\",\n                to_jetton_master_address=\"EQ...\",\n                jetton_amount=0.01,\n                from_jetton_decimals=9,\n                to_jetton_decimals=9,\n            ),\n        ]\n    )\n\n    print(\"Successfully swapped TON to Jetton!\")\n    print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"how-to/get-contract-code-and-data/","title":"Get Contract code and data","text":"<p>To retrieve the code and data of a contract, you can use TON explorers such as tonviewer.com, tonscan.org, and others, or use the <code>get_raw_account</code> method programmatically.</p>"},{"location":"how-to/get-contract-code-and-data/#using-ton-explorers","title":"Using TON explorers","text":"<ol> <li>Open Tonviewer.</li> <li>Enter the contract address into the search field.</li> <li>Navigate to the Code tab.</li> <li>The Bytecode section contains the contract code.</li> <li>The Raw data section contains the contract data.</li> </ol>"},{"location":"how-to/get-contract-code-and-data/#using-get_raw_account-method","title":"Using <code>get_raw_account</code> method","text":"<pre><code>from tonutils.client import ToncenterV3Client\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    contract_address = \"EQ...\"\n    account = await client.get_raw_account(contract_address)\n\n    # Print contract code (hex-encoded BOC)\n    print(account.code.to_boc().hex())\n\n    # Print contract data (hex-encoded BOC)\n    print(account.data.to_boc().hex())\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre> <p>See RawAccount fields overview</p>"},{"location":"how-to/get-contract-information/","title":"Get Contract information","text":"<p>This example shows how to retrieve full contract details, including balance, status, code, data, and last transaction metadata.</p> <pre><code>from tonutils.client import ToncenterV3Client\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    contract_address = \"EQ...\"\n\n    contract = await client.get_raw_account(contract_address)\n\n    print(f\"Balance: {contract.balance}\")\n    print(f\"Status: {contract.status}\")\n    print(f\"Code: {contract.code}\")\n    print(f\"Data: {contract.data}\")\n    print(f\"Last Transaction LT: {contract.last_transaction_lt}\")\n    print(f\"Last Transaction Hash: {contract.last_transaction_hash}\")\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"how-to/get-contract-information/#rawaccount-fields-overview","title":"<code>RawAccount</code> fields overview","text":"<ul> <li> <p>balance \u2192 integer (in nanoTON)   Current balance of the contract.</p> </li> <li> <p>status \u2192 string   Contract status, one of:</p> <ul> <li><code>active</code> \u2192 contract exists and is active</li> <li><code>nonexist</code> \u2192 contract does not exist</li> <li><code>frozen</code> \u2192 contract is frozen</li> <li><code>uninit</code> \u2192 contract exists but is not initialized</li> </ul> </li> <li> <p>code \u2192 <code>Cell</code> (optional)   The contract\u2019s executable code (if present).</p> </li> <li> <p>data \u2192 <code>Cell</code> (optional)   The contract\u2019s persistent data (if present).</p> </li> <li> <p>last_transaction_lt \u2192 integer (optional)   Logical time (LT) of the most recent transaction.</p> </li> <li> <p>last_transaction_hash \u2192 string (optional)   Hash of the most recent transaction.</p> </li> <li> <p>state_init \u2192 <code>StateInit</code> (optional)   Combined object representing the full contract state if both code and data are available.</p> </li> </ul>"},{"location":"how-to/get-jetton-wallet-address/","title":"Get Jetton Wallet address","text":"<p>There are several ways to obtain the address of a Jetton Wallet.</p>"},{"location":"how-to/get-jetton-wallet-address/#standard-jetton","title":"Standard Jetton","text":""},{"location":"how-to/get-jetton-wallet-address/#using-get-method","title":"Using get-method","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStandard\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    owner_address = \"UQ...\"\n    jetton_master_address = \"EQ...\"\n\n    wallet_address = await JettonMasterStandard.get_wallet_address(\n        client,\n        owner_address,\n        jetton_master_address,\n    )\n    print(wallet_address.to_str())\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"how-to/get-jetton-wallet-address/#calculating-locally","title":"Calculating locally","text":"<p>Note</p> <p>Prepare the Jetton Wallet contract code by following the instructions in Get Contract code and data.</p> <pre><code>from tonutils.jetton import JettonMasterStandard\n\n\ndef main() -&gt; None:\n    owner_address = \"UQ...\"\n    jetton_wallet_code = \"...\"\n    jetton_master_address = \"EQ...\"\n\n    wallet_address = JettonMasterStandard.calculate_user_jetton_wallet_address(\n        owner_address,\n        jetton_wallet_code,\n        jetton_master_address,\n    )\n    print(wallet_address.to_str())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"how-to/get-jetton-wallet-address/#stablecoin-jetton","title":"Stablecoin Jetton","text":"<p>e.g., USD\u20ae, NOT</p>"},{"location":"how-to/get-jetton-wallet-address/#using-get-method_1","title":"Using get-method","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStablecoin\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    owner_address = \"UQ...\"\n    jetton_master_address = \"EQ...\"\n\n    wallet_address = await JettonMasterStablecoin.get_wallet_address(\n        client,\n        owner_address,\n        jetton_master_address,\n    )\n    print(wallet_address.to_str())\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"how-to/get-jetton-wallet-address/#calculating-locally_1","title":"Calculating locally","text":"<p>Note</p> <p>Prepare the Jetton Wallet contract code by following the instructions in Get Contract code and data.</p> <pre><code>from tonutils.jetton import JettonMasterStablecoin\n\n\ndef main() -&gt; None:\n    owner_address = \"UQ...\"\n    jetton_wallet_code = \"...\"\n    jetton_master_address = \"EQ...\"\n\n    wallet_address = JettonMasterStablecoin.calculate_user_jetton_wallet_address(\n        owner_address,\n        jetton_wallet_code,\n        jetton_master_address,\n    )\n    print(wallet_address.to_str())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"how-to/get-nft-item-address/","title":"Get NFT Item address","text":"<p>There are several ways to obtain the address of an NFT Item.</p>"},{"location":"how-to/get-nft-item-address/#standard-collections","title":"Standard collections","text":""},{"location":"how-to/get-nft-item-address/#using-get-method","title":"Using get-method","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.nft import Collection\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    nft_index = 1\n    collection_address = \"EQ...\"\n\n    nft_address = await Collection.get_nft_address_by_index(\n        client,\n        nft_index,\n        collection_address,\n    )\n    print(nft_address.to_str())\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"how-to/get-nft-item-address/#calculating-locally","title":"Calculating locally","text":"<p>Note</p> <p>Prepare the NFT Item contract code by following the instructions in Get Contract code and data.</p> <pre><code>from tonutils.nft import Collection\n\n\ndef main() -&gt; None:\n    nft_index = 1\n    nft_item_code = \"...\"\n    collection_address = \"EQ...\"\n\n    nft_address = Collection.calculate_nft_item_address(\n        nft_index,\n        nft_item_code,\n        collection_address,\n    )\n    print(nft_address.to_str())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"how-to/get-nft-item-address/#ton-dns-domains-collection","title":"TON DNS Domains collection","text":"<p>Note</p> <p>The index is computed as <code>slice_hash(name)</code>. See Use FunC hash functions for details.</p>"},{"location":"how-to/get-nft-item-address/#using-get-method_1","title":"Using get-method","text":"<pre><code>from pytoniq_core import begin_cell\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import Collection\nfrom tonutils.utils import slice_hash\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    domain_name = \"temp\"\n    domain_index = slice_hash(begin_cell().store_string(domain_name))[1]\n    collection_address = \"EQC3dNlesgVD8YbAazcauIrXBPfiVhMMr5YYk2in0Mtsz0Bz\"\n\n    nft_address = await Collection.get_nft_address_by_index(\n        client,\n        domain_index,\n        collection_address,\n    )\n    print(nft_address.to_str())\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"how-to/get-nft-item-address/#telegram-gifts-anonymous-telegram-numbers","title":"Telegram Gifts / Anonymous Telegram Numbers","text":"<p>Note</p> <p>The index is computed as <code>string_hash(telemint_token_name)</code>. See Use FunC hash functions for details.</p>"},{"location":"how-to/get-nft-item-address/#using-get-method_2","title":"Using get-method","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.nft import Collection\nfrom tonutils.utils import string_hash\n\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    token_name = \"8888888\"\n    token_index = string_hash(token_name)[1]\n    collection_address = \"EQAOQdwdw8kGftJCSFgOErM1mBjYPe4DBPq8-AhF6vr9si5N\"\n\n    nft_address = await Collection.get_nft_address_by_index(\n        client,\n        token_index,\n        collection_address,\n    )\n    print(nft_address.to_str())\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre>"},{"location":"how-to/use-func-hash-functions/","title":"Use FunC hash functions","text":""},{"location":"how-to/use-func-hash-functions/#cell_hash","title":"cell_hash","text":"<p>Calculates the representation hash of the given cell c and returns it as a 256-bit unsigned integer x. This function is handy for signing and verifying signatures of arbitrary entities structured as a tree of cells.</p> <pre><code>from tonutils.utils import cell_hash\nfrom pytoniq_core import begin_cell\n\n\ndef main() -&gt; None:\n    c = begin_cell().store_string(\"ness\").end_cell()\n    cell_hash_result = cell_hash(c)\n    print(f\"bytes: {cell_hash_result[0]}\")\n    print(f\"int: {cell_hash_result[1]}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"how-to/use-func-hash-functions/#slice_hash","title":"slice_hash","text":"<p>Computes the hash of the given slice s and returns it as a 256-bit unsigned integer x. The result is equivalent to creating a standard cell containing only the data and references from s and then computing its hash using cell_hash.</p> <pre><code>from tonutils.utils import slice_hash\nfrom pytoniq_core import begin_cell\n\n\ndef main() -&gt; None:\n    s = begin_cell().store_string(\"ness\")\n    slice_hash_result = slice_hash(s)\n    print(f\"bytes: {slice_hash_result[0]}\")\n    print(f\"int: {slice_hash_result[1]}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"how-to/use-func-hash-functions/#string_hash","title":"string_hash","text":"<p>Calculates the SHA-256 hash of the data bits in the given slice s. A cell underflow exception is thrown if the bit length of s is not a multiple of eight. The hash is returned as a 256-bit unsigned integer x.</p> <pre><code>from tonutils.utils import string_hash\n\n\ndef main() -&gt; None:\n    string_hash_result = string_hash(\"ness\")\n    print(f\"bytes: {string_hash_result[0]}\")\n    print(f\"int: {string_hash_result[1]}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"}]}