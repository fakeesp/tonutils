{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TON Cookbook","text":"<p>This documentation is under development and is not the final version. Content, structure, and examples may change significantly in upcoming updates.</p>"},{"location":"cookbook/cnft/","title":"Creating Compressed NFTs","text":""},{"location":"cookbook/cnft/#introduction","title":"Introduction","text":"<p>Compressed NFT (cNFT) is a specialized digital asset format that optimizes data storage. Data compression algorithms reduce file sizes while preserving each asset\u2019s uniqueness. This process saves server space and lowers data storage and transmission costs. In addition, Merkle trees minimize storage requirements and enhance the efficiency of cNFT collections.</p>"},{"location":"cookbook/cnft/#features","title":"Features","text":"<ul> <li>Resource savings: Merkle trees store only essential data, reducing gas costs and network load.  </li> <li>Improved scalability: Efficient contracts can handle large NFT volumes without performance loss.  </li> <li>Optimized data storage: Keeping minimal on-chain information boosts system responsiveness and saves space.  </li> <li>Enhanced security: Merkle trees enable fast data integrity checks and robust asset protection.  </li> <li>Cost reduction: Shift minting costs to end users and create \u201cvirtual\u201d on-chain items only when needed.</li> </ul>"},{"location":"cookbook/cnft/#supporting-compressed-nft-in-wallets-and-marketplaces","title":"Supporting compressed NFT in wallets and marketplaces","text":"<p>Current limitations Most popular wallets and marketplaces do not display unclaimed cNFTs or NFTs from collections that are not official partners. For example, the Telegram wallet and the Getgems marketplace index only the first 200 items for unofficial collections, which poses challenges for larger collections.</p> <p>Attack scenario A malicious actor could create hundreds of thousands of NFTs at minimal cost, forcing marketplaces to store all related data\u2014even if the attacker does not host the items but generates them on demand.</p> <p>Potential solution Provide a dedicated interface where users can claim their cNFTs. Once claimed, NFTs are indexed and displayed in wallets and marketplaces as standard NFTs, ensuring better visibility and accessibility.</p>"},{"location":"cookbook/cnft/#configuration-and-deployment-guide","title":"Configuration and deployment guide","text":""},{"location":"cookbook/cnft/#nft-collection-and-item-preparation","title":"NFT collection and item preparation","text":"<p>Before deployment, you need to prepare the metadata and images for your NFTs.</p>"},{"location":"cookbook/cnft/#metadata-preparation","title":"Metadata preparation","text":"<ul> <li>Collection metadata   Create a <code>collection.json</code> file that includes the required fields as specified in the NFT token data standard. Example:</li> </ul> <pre><code>{\n    \"name\": \"&lt;collection name&gt;\",\n    \"description\": \"&lt;collection description&gt;\",\n    \"image\": \"&lt;link to the image (e.g. https://yourdomain.com/logo.png)&gt;\"\n}\n</code></pre> <ul> <li> <p>NFT item metadata     For each NFT, create a separate JSON file (e.g., <code>0.json</code>, <code>1.json</code>, etc.) with the required fields as specified in the NFT token data standard. Example:</p> <pre><code>{\n    \"name\": \"&lt;item name&gt;\",\n    \"description\": \"&lt;item description&gt;\",\n    \"image\": \"&lt;link to the image (e.g. https://yourdomain.com/0.png)&gt;\"\n}\n</code></pre> </li> </ul>"},{"location":"cookbook/cnft/#resource-preparation","title":"Resource preparation","text":"<ul> <li>Images: Prepare images for the collection (for example, <code>logo.png</code> for the avatar) and for each NFT (for example, <code>0.png</code>, <code>1.png</code>, etc.).</li> <li>JSON files: Host your <code>collection.json</code> and NFT JSON files on a publicly accessible server or repository. Ensure each file has a unique URL.</li> </ul> <p>Note: All images and JSON files must be directly accessible via their URLs.</p>"},{"location":"cookbook/cnft/#ton-connect-manifest-preparation","title":"TON Connect manifest preparation","text":"<p>Create a TON Connect manifest JSON file to describe your application during the wallet connection process. Example:</p> <pre><code>{\n  \"url\": \"&lt;app url&gt;\",\n  \"name\": \"&lt;app name&gt;\",\n  \"iconUrl\": \"&lt;app icon url&gt;\"\n}\n</code></pre> <p>Note: Ensure that this file is publicly accessible via its URL.</p>"},{"location":"cookbook/cnft/#owner-list-preparation","title":"Owner list preparation","text":"<p>Prepare an <code>owners.txt</code> file that lists the addresses of NFT owners, one per line. The first address corresponds to item index <code>0</code>, the second to item index <code>1</code>, and so on. Example:</p> <pre><code>UQDYzZmfsrGzhObKJUw4gzdeIxEai3jAFbiGKGwxvxHinf4K\nUQCDrgGaI6gWK-qlyw69xWZosurGxrpRgIgSkVsgahUtxZR0\n</code></pre>"},{"location":"cookbook/cnft/#infrastructure-preparation","title":"Infrastructure preparation","text":"<p>Set up a server to host your API and the interface for claiming NFTs. Also, obtain a domain for accessing the API. In this example, a local test deployment is run on a home machine using ngrok to create a public URL.</p>"},{"location":"cookbook/cnft/#claiming-api-and-interface-setup","title":"Claiming API and interface setup","text":"<ol> <li> <p>Clone the repository     Clone the project containing all necessary source files:</p> <p>```bash git clone https://github.com/nessshon/cnft-toolbox  ````</p> </li> <li> <p>Install dependencies     Install Docker, Docker Compose, and ngrok, and ensure they are properly configured on your machine.</p> </li> <li> <p>Create a Telegram bot     Create a Telegram bot and obtain its API token.</p> </li> <li> <p>Expose your API     Use ngrok to create a public URL for testing:</p> <pre><code>ngrok http 8080 \n</code></pre> <p>For production: Set up a custom domain and configure Nginx to proxy requests to your API on port 8080. This involves:</p> <ul> <li>Registering a domain and pointing it to your server.</li> <li>Configuring Nginx to proxy requests to your API on port 8080.</li> <li>Create a <code>.env</code> file Duplicate the <code>env.example</code> file to <code>.env</code> and update it with your specific configuration. The table below describes each key:</li> </ul> Key Description Example Notes <code>PORT</code> Port on which the API will run. <code>8080</code> <code>ADMIN_USERNAME</code> Admin username for accessing restricted functionalities. <code>admin</code> <code>ADMIN_PASSWORD</code> Admin password for accessing restricted functionalities. <code>password</code> <code>DEPTH</code> Depth for the NFT collection (max items = <code>2^DEPTH</code>; maximum DEPTH is 30). <code>20</code> <code>IS_TESTNET</code> Specify if you are connecting to the TON testnet (<code>true</code>) or mainnet (<code>false</code>). <code>true</code> or <code>false</code> <code>POSTGRES_PASSWORD</code> Password for PostgreSQL authentication. <code>secret</code> <code>POSTGRES_DB</code> Name of the PostgreSQL database. <code>merkleapi</code> <code>POSTGRES_URI</code> Full connection URI for PostgreSQL. <code>postgresql://postgres:secret@db:5432/merkleapi</code> <code>BOT_TOKEN</code> Token for your Telegram bot (from @BotFather). <code>123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11</code> Used for the NFT claiming interface. <code>API_BASE_URL</code> External domain of your API. <code>https://example.ngrok.io</code> Replace with your public URL (e.g., via ngrok). <code>TONCONNECT_MANIFEST_URL</code> URL for the TON Connect manifest file. <code>https://example.com/tonconnect-manifest.json</code> Replace with the public URL of your manifest file. <code>COLLECTION_ADDRESS</code> Address of the NFT collection. Fill this in after deploying the collection. </li> <li> <p>Start the API and database     Run the following command to start the API and database:</p> <pre><code>docker-compose up -d db api \n</code></pre> </li> <li> <p>Migrate the database     Create the required tables in the database:</p> <pre><code>docker-compose exec api /ctl migrate \n</code></pre> </li> <li> <p>Add owners     Place your <code>owners.txt</code> file (containing owner addresses) into the <code>api</code> folder, then run:</p> <pre><code>docker-compose exec api /ctl add /api/owners.txt \n</code></pre> </li> <li> <p>Rediscover items     In your browser, navigate to <code>&lt;API_URI&gt;/admin/rediscover</code> and log in using your <code>ADMIN_USERNAME</code> and <code>ADMIN_PASSWORD</code>. If successful, you will see <code>ok</code> in the browser. After a short time (depending on the number of items), a file (e.g., <code>1.json</code>) appears in the <code>api/apidata/upd</code> folder.</p> </li> <li> <p>Generate an update     Run the following command to generate an update:</p> <pre><code>docker-compose exec api /ctl genupd &lt;path-to-update-file&gt; &lt;collection-owner&gt; &lt;collection-meta&gt; &lt;item-meta-prefix&gt; &lt;royalty-base&gt; &lt;royalty-factor&gt; &lt;royalty-recipient&gt; &lt;api-uri-including-v1&gt; \n</code></pre> <p>Replace the placeholders as follows:</p> <ul> <li><code>&lt;path-to-update-file&gt;</code>: Path to the update file created in step 9 (e.g., <code>api/apidata/upd/1.json</code>).</li> <li><code>&lt;collection-owner&gt;</code>: Address of the NFT collection owner.</li> <li><code>&lt;collection-meta&gt;</code>: Full URL to the collection metadata file (e.g., <code>https://yourdomain.com/collection.json</code>).</li> <li><code>&lt;item-meta-prefix&gt;</code>: Common prefix for item metadata (for example, if item 0 has metadata at <code>https://yourdomain.com/0.json</code>, use <code>https://yourdomain.com/</code>).</li> <li><code>&lt;royalty-base&gt;</code>: Numerator for royalties (for example, <code>10</code> for 10% if royalty-factor is 100).</li> <li><code>&lt;royalty-factor&gt;</code>: Denominator for royalties (for example, <code>100</code>).</li> <li><code>&lt;royalty-recipient&gt;</code>: Address receiving royalties (this can be the same as <code>&lt;collection-owner&gt;</code>).</li> <li><code>&lt;api-uri-including-v1&gt;</code>: Public API URL with the <code>/v1</code> postfix (for example, if you used <code>https://yourapi.com/admin/rediscover</code> to generate the update file, use <code>https://yourapi.com/v1</code> here).</li> <li>Invoke the <code>ton://</code> deeplink After generating the update, a <code>ton://</code> link appears in the console logs. Follow the link and confirm the transaction. For convenience, you can paste the link into a QR code generator and scan the QR code with the Tonhub wallet (on testnet or mainnet).</li> </ul> </li> <li> <p>Set the collection address     In your browser, navigate to <code>&lt;API_URI&gt;/admin/setaddr/&lt;collection-address&gt;</code>, replacing <code>&lt;collection-address&gt;</code> with the address observed during the deployment step.</p> </li> <li> <p>Wait for confirmation     Monitor the container API logs until you see a message indicating a <code>committed state</code>.</p> <pre><code>docker-compose logs api \n</code></pre> </li> <li> <p>Deployment complete!</p> </li> </ol>"},{"location":"cookbook/cnft/#run-the-telegram-bot-for-nft-claiming-interface","title":"Run the Telegram bot for NFT claiming interface","text":"<ol> <li> <p>Update the <code>.env</code> file     Add the <code>COLLECTION_ADDRESS</code> obtained during deployment to your <code>.env</code> file.</p> </li> <li> <p>Start the Telegram bot     Run the following command to start the bot:</p> <pre><code>docker-compose up -d redis bot \n</code></pre> </li> <li> <p>Interact with the bot     Open Telegram, navigate to your bot, and follow its instructions to claim NFTs or perform other actions.</p> </li> <li> <p>Done!</p> </li> </ol>"},{"location":"cookbook/cnft/#updating-owners","title":"Updating owners","text":"<p>Follow these steps to update the list of owners and integrate the changes into your NFT collection:</p> <ol> <li> <p>Prepare the new owners file     Create a <code>new-owners.txt</code> file with the new owner addresses and place it in the <code>api</code> folder.</p> </li> <li> <p>Add new owners     Run:</p> <pre><code>docker-compose exec api /ctl add /api/new-owners.txt \n</code></pre> </li> <li> <p>Rediscover items     In your browser, navigate to <code>&lt;API_URI&gt;/admin/rediscover</code> and log in with your <code>ADMIN_USERNAME</code> and <code>ADMIN_PASSWORD</code>.</p> </li> <li> <p>Locate the update file     After rediscovering, locate the new update file in the <code>api/apidata/upd</code> folder (for example, <code>2.json</code> if the previous update was <code>1.json</code>).</p> </li> <li> <p>Generate an update     Run:</p> <pre><code>docker-compose exec api /ctl genupd &lt;path-to-update-file&gt; &lt;collection-address&gt; \n</code></pre> <p>Replace <code>&lt;path-to-update-file&gt;</code> with the new update file\u2019s path (e.g., <code>api/apidata/upd/2.json</code>) and <code>&lt;collection-address&gt;</code> with the NFT collection address.</p> </li> <li> <p>Invoke the <code>ton://</code> deeplink     Follow the generated <code>ton://</code> link and confirm the transaction. You may also generate a QR code from the link and scan it with the Tonhub wallet.</p> </li> <li> <p>Wait for confirmation     Monitor the container API logs until you see a message indicating a <code>committed state</code>.</p> <pre><code>docker-compose logs api \n</code></pre> </li> <li> <p>Done!</p> </li> </ol>"},{"location":"cookbook/cnft/#conclusion","title":"Conclusion","text":"<p>The Compressed NFT standard transforms the creation and management of NFT collections by offering a scalable, cost-effective solution for mass NFT production. By addressing the limitations of existing standards, this approach paves the way for broader adoption and innovative applications of NFT technology in community building and marketing campaigns.</p>"},{"location":"cookbook/cnft/#see-also","title":"See also","text":"<ul> <li>Compressed NFT standard implementation</li> <li>Reference augmenting API implementation</li> <li>Compressed NFT toolbox</li> </ul>"},{"location":"cookbook/subdomains/","title":"Minting TON DNS Subdomains","text":""},{"location":"cookbook/subdomains/#introduction","title":"Introduction","text":"<p>This guide walks you through creating and managing subdomains on the TON blockchain using open-source tools. It covers deploying subdomain management contracts, issuing subdomains, and managing DNS records with practical examples.</p>"},{"location":"cookbook/subdomains/#implementation","title":"Implementation","text":"<p>There are two open-source implementations available for managing subdomains on TON, depending on the level of complexity and control you need:</p>"},{"location":"cookbook/subdomains/#subdomain-collection","title":"Subdomain Collection","text":"<p>GitHub \u2197</p> <p>This is a more advanced solution where each subdomain is represented as an NFT. The owner of the collection is responsible for issuing subdomains, while each NFT owner has full control over their subdomain.</p> <p>Key Features:</p> <ul> <li>Subdomains can be transferred or sold</li> <li>Decentralized record management \u2014 each subdomain has its own smart contract</li> <li>Requires additional infrastructure (e.g., metadata API)</li> </ul>"},{"location":"cookbook/subdomains/#subdomain-manager","title":"Subdomain Manager","text":"<p>GitHub \u2197</p> <p>This is a basic implementation where a single smart contract acts as the centralized subdomain manager. The administrator is responsible for issuing subdomains and configuring their DNS records.</p> <p>Key Features:</p> <ul> <li>Suitable for simple use cases</li> <li>Quick and easy setup</li> <li>Centralized control through one smart contract</li> </ul>"},{"location":"cookbook/subdomains/#environment-setup","title":"Environment Setup","text":"<p>This guide uses Python along with the open-source tonutils library, which supports both subdomain management implementations.</p>"},{"location":"cookbook/subdomains/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+</li> <li>A registered .ton domain:</li> <li>Mainnet: dns.ton.org</li> <li>Testnet: dns.ton.org?testnet=true</li> </ul>"},{"location":"cookbook/subdomains/#install-dependencies","title":"Install Dependencies","text":"<p>Install the required Python library:</p> <pre><code>pip install tonutils\n</code></pre>"},{"location":"cookbook/subdomains/#additional-requirements-for-subdomain-collection","title":"Additional Requirements for Subdomain Collection","text":"<p>If you\u2019re using the Subdomain Collection approach, you\u2019ll also need:</p> <ul> <li>A server to host the metadata API</li> <li>A domain name pointing to that server for metadata access</li> <li>Docker and Docker Compose for easy deployment of the API</li> </ul>"},{"location":"cookbook/subdomains/#subdomain-collection_1","title":"Subdomain Collection","text":""},{"location":"cookbook/subdomains/#metadata-setup","title":"Metadata Setup","text":"<p>Before deploying the subdomain collection, you need to launch the metadata API. This service is responsible for generating dynamic images and attributes for your subdomain NFTs, making them visually identifiable.</p> <ol> <li> <p>Clone the repository:    <pre><code>git clone https://github.com/nessshon/subdomains-toolbox\ncd metadata-api\n</code></pre></p> </li> <li> <p>Start the API using Docker:    The API will be running on port <code>8001</code>. You will need to configure SSL and set up a reverse proxy to expose it    securely.    <pre><code>docker-compose up -d\n</code></pre></p> </li> <li> <p>Test the API:    Visit <code>https://your-domain.com/api/ton/example.png</code> in your browser. If set up correctly, you\u2019ll see a generated    image for the subdomain <code>example</code>.</p> </li> </ol>"},{"location":"cookbook/subdomains/#deploy-the-collection","title":"Deploy the Collection","text":"<p>Once the API is running, you can deploy the NFT collection smart contract for your subdomains.</p> <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns import Domain\nfrom tonutils.dns.subdomain_collection import SubdomainCollection\nfrom tonutils.dns.subdomain_collection.content import SubdomainCollectionContent\nfrom tonutils.dns.subdomain_collection.data import FullDomain\nfrom tonutils.nft.royalty_params import RoyaltyParams\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import TransferData\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# NFT domain name and address from TON DNS Domains\n# Obtainable from https://dns.ton.org/ or https://dns.ton.org/?testnet=true\nDOMAIN_NAME = \"ghost\"  # ghost \u2192 ghost.ton\nDOMAIN_ADDRESS = \"EQ...\"\n\n# Royalty parameters: base and factor for calculating the royalty\nROYALTY_BASE = 1000\nROYALTY_FACTOR = 55  # 5.5% royalty\n\n# Base URL of the API for generating metadata for NFTs\n# API source code: https://github.com/nessshon/subdomains-toolbox\nAPI_BASE_URL = \"https://your-domain.com/api/ton/\"\n\n# Metadata for the NFT collection\nCOLLECTION_METADATA = {\n  \"name\": f\"{DOMAIN_NAME.title()} DNS Domains\",\n  \"image\": f\"{API_BASE_URL}{DOMAIN_NAME}.png\",\n  \"description\": f\"*.{DOMAIN_NAME}.ton domains\",\n  \"prefix_uri\": API_BASE_URL,\n}\n\"\"\"\nExample of the metadata for the NFT collection (JSON format):\n{\n    \"name\": \"Ghost DNS Domains\",\n    \"image\": \"https://your-domain.com/api/ton/ghost.png\",\n    \"description\": \"*.ghost.ton domains\",\n    \"prefix_uri\": \"https://your-domain.com/api/ton/\"\n}\n\"\"\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  collection = SubdomainCollection(\n    owner_address=wallet.address,\n    content=SubdomainCollectionContent(**COLLECTION_METADATA),\n    royalty_params=RoyaltyParams(\n      base=ROYALTY_BASE,\n      factor=ROYALTY_FACTOR,\n      address=wallet.address,\n    ),\n    full_domain=FullDomain(DOMAIN_NAME, \"ton\"),\n  )\n\n  tx_hash = await wallet.batch_transfer(\n    [\n      # Deploy collection\n      TransferData(\n        destination=collection.address,\n        amount=0.05,\n        body=collection.build_deploy_body(),\n        state_init=collection.state_init,\n      ),\n      # Bind Subdomain Collection to the main domain\n      TransferData(\n        destination=DOMAIN_ADDRESS,\n        amount=0.05,\n        body=Domain.build_set_next_resolver_record_body(collection.address),\n      ),\n    ]\n  )\n\n  print(f\"Successfully deployed Subdomain Collection at address: {collection.address.to_str()}\")\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre>"},{"location":"cookbook/subdomains/#minting-subdomains","title":"Minting Subdomains","text":"<p>To mint a new subdomain as an NFT:</p> <ol> <li>Open your TON wallet (e.g., Tonkeeper).</li> <li>Send 0.1 TON to the Subdomain Collection contract address (printed during deployment).</li> <li>In the transaction comment field, enter the desired subdomain name (e.g., <code>alice</code> for <code>alice.ghost.ton</code>).</li> <li>Ensure the subdomain name is valid (alphanumeric, no special characters) and not already minted.</li> <li>After the transaction is confirmed, the subdomain NFT will be sent to your wallet.</li> </ol>"},{"location":"cookbook/subdomains/#managing-records","title":"Managing Records","text":""},{"location":"cookbook/subdomains/#setting-records","title":"Setting Records","text":"<p>The record-setting mechanism for NFT subdomains is similar to the one used in the TON DNS Domains collection. You can assign one of the following record types to a subdomain \u2014 examples for each are provided below.</p> Set Wallet Record <pre><code>import asyncio\nfrom pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n# Address of the wallet to be set (e.g., UQ...)\nWALLET_ADDRESS = \"UQ...\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = Domain.build_set_wallet_record_body(Address(WALLET_ADDRESS))\n\n  tx_hash = await wallet.transfer(\n    destination=NFT_DOMAIN_ADDRESS,\n    amount=0.005,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre> Set Site Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n# ADNL address (e.g., \"a1b2c3...\")\nADNL_ADDRESS = \"a1b2c3...\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = Domain.build_set_site_record_body(ADNL_ADDRESS)\n\n  tx_hash = await wallet.transfer(\n    destination=NFT_DOMAIN_ADDRESS,\n    amount=0.005,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre> Set TON Storage Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n# Hex-encoded BAG ID (e.g., \"1234567890abcdef...\")\nBAG_ID = \"1234567890abcdef...\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = Domain.build_set_storage_record_body(BAG_ID)\n\n  tx_hash = await wallet.transfer(\n    destination=NFT_DOMAIN_ADDRESS,\n    amount=0.005,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre> Set Next Resolver Record <pre><code>import asyncio\n\nfrom pytoniq_core import Address\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n# Address of the next resolver contract (e.g., EQ...)\nCONTRACT_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = Domain.build_set_next_resolver_record_body(Address(CONTRACT_ADDRESS))\n\n  tx_hash = await wallet.transfer(\n    destination=NFT_DOMAIN_ADDRESS,\n    amount=0.005,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre>"},{"location":"cookbook/subdomains/#deleting-records","title":"Deleting Records","text":"<p>Similarly, you can delete existing records. Below are examples for each type.</p> Delete Wallet Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = Domain.build_delete_wallet_record_body()\n\n  tx_hash = await wallet.transfer(\n    destination=NFT_DOMAIN_ADDRESS,\n    amount=0.005,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre> Delete Site Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = Domain.build_delete_site_record_body()\n\n  tx_hash = await wallet.transfer(\n    destination=NFT_DOMAIN_ADDRESS,\n    amount=0.005,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre> Delete TON Storage Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = Domain.build_delete_storage_record_body()\n\n  tx_hash = await wallet.transfer(\n    destination=NFT_DOMAIN_ADDRESS,\n    amount=0.005,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre> Delete Next Resolver Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.contract import Domain\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the NFT subdomain (e.g., EQ...)\nNFT_DOMAIN_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = Domain.build_delete_next_resolver_record_body()\n\n  tx_hash = await wallet.transfer(\n    destination=NFT_DOMAIN_ADDRESS,\n    amount=0.005,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre>"},{"location":"cookbook/subdomains/#subdomain-manager_1","title":"Subdomain Manager","text":""},{"location":"cookbook/subdomains/#deploy-the-manager","title":"Deploy the Manager","text":"<p>Below is an example of how to deploy the Subdomain Manager using the tonutils Python library. This script initializes the smart contract, links it to the main domain, and sends the necessary transactions from your wallet.</p> <pre><code>import asyncio\nfrom pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns import Domain\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\nfrom tonutils.wallet.data import TransferData\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Administrator address for managing the Subdomain Manager (e.g., UQ...)\nADMIN_ADDRESS = \"UQ...\"\n\n# NFT address of the main domain from TON DNS Domains collection (e.g., EQ...)\nDOMAIN_ADDRESS = \"EQ...\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  subdomain_manager = SubdomainManager(Address(ADMIN_ADDRESS))\n\n  tx_hash = await wallet.batch_transfer(\n    [\n      # Deploy Subdomain Manager\n      TransferData(\n        destination=subdomain_manager.address,\n        amount=0.05,\n        state_init=subdomain_manager.state_init,\n      ),\n      # Bind Subdomain Manager to the main domain as a next resolver\n      TransferData(\n        destination=DOMAIN_ADDRESS,\n        amount=0.05,\n        body=Domain.build_set_next_resolver_record_body(subdomain_manager.address),\n      ),\n    ]\n  )\n\n  print(f\"Successfully deployed Subdomain Manager at address: {subdomain_manager.address.to_str()}\")\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre>"},{"location":"cookbook/subdomains/#setting-records_1","title":"Setting Records","text":"<p>You can set one of the following record types for a subdomain. Below are examples for each.</p> Set Wallet Record <pre><code>import asyncio\nfrom pytoniq_core import Address\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# Address of the wallet to be set for the subdomain (e.g., UQ...)\nWALLET_ADDRESS = \"UQ...\"\n\n# Subdomain to be registered (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = SubdomainManager.build_set_wallet_record_body(SUBDOMAIN, Address(WALLET_ADDRESS))\n\n  tx_hash = await wallet.transfer(\n    destination=SUBDOMAIN_MANAGER_ADDRESS,\n    amount=0.02,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre> Set Site Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# ADNL address for the subdomain (e.g., \"a1b2c3...\")\nADNL_ADDRESS = \"a1b2c3...\"\n\n# Subdomain to be registered (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = SubdomainManager.build_set_site_record_body(SUBDOMAIN, ADNL_ADDRESS)\n\n  tx_hash = await wallet.transfer(\n    destination=SUBDOMAIN_MANAGER_ADDRESS,\n    amount=0.02,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre> Set TON Storage Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# ID of the storage bag (hex string, e.g., \"1234567890abcdef...\")\nBAG_ID = \"1234567890abcdef...\"\n\n# Subdomain to be registered (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = SubdomainManager.build_set_storage_record_body(SUBDOMAIN, BAG_ID)\n\n  tx_hash = await wallet.transfer(\n    destination=SUBDOMAIN_MANAGER_ADDRESS,\n    amount=0.02,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre> Set Next Resolver Record <pre><code>import asyncio\n\nfrom pytoniq_core import Address\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# Address of the next resolver contract (e.g., EQ...)\nCONTRACT_ADDRESS = \"EQ...\"\n\n# Subdomain to be registered (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = SubdomainManager.build_set_next_resolver_record_body(SUBDOMAIN, Address(CONTRACT_ADDRESS))\n\n  tx_hash = await wallet.transfer(\n    destination=SUBDOMAIN_MANAGER_ADDRESS,\n    amount=0.02,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre>"},{"location":"cookbook/subdomains/#deleting-records_1","title":"Deleting Records","text":"<p>Similarly, you can delete existing records. Below are examples for each type.</p> Delete Wallet Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# Subdomain to be deleted (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = SubdomainManager.build_delete_wallet_record_body(SUBDOMAIN)\n\n  tx_hash = await wallet.transfer(\n    destination=SUBDOMAIN_MANAGER_ADDRESS,\n    amount=0.02,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre> Delete Site Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# Subdomain to be deleted (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = SubdomainManager.build_delete_site_record_body(SUBDOMAIN, False)\n\n  tx_hash = await wallet.transfer(\n    destination=SUBDOMAIN_MANAGER_ADDRESS,\n    amount=0.02,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre> Delete TON Storage Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# Subdomain to be deleted (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = SubdomainManager.build_delete_storage_record_body(SUBDOMAIN, True)\n\n  tx_hash = await wallet.transfer(\n    destination=SUBDOMAIN_MANAGER_ADDRESS,\n    amount=0.02,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre> Delete Next Resolver Record <pre><code>import asyncio\n\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.dns.subdomain_manager import SubdomainManager\nfrom tonutils.wallet import WalletV4R2\n\n# Set to True for test network\nIS_TESTNET = True\n\n# Mnemonic phrase for the wallet (list of 24 words, e.g., [\"word1\", \"word2\", ...])\nMNEMONIC: list[str] = []\n\n# Address of the subdomain manager contract (e.g., EQ...)\nSUBDOMAIN_MANAGER_ADDRESS = \"EQ...\"\n\n# Subdomain to be deleted (e.g., \"example\" for example.your-domain.ton)\nSUBDOMAIN = \"example\"\n\n\nasync def main() -&gt; None:\n  client = ToncenterV3Client(is_testnet=IS_TESTNET)\n  wallet, _, _, _ = WalletV4R2.from_mnemonic(client, MNEMONIC)\n\n  body = SubdomainManager.build_delete_next_resolver_record_body(SUBDOMAIN)\n\n  tx_hash = await wallet.transfer(\n    destination=SUBDOMAIN_MANAGER_ADDRESS,\n    amount=0.02,\n    body=body,\n  )\n  print(f\"Transaction hash: {tx_hash}\")\n\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n</code></pre>"},{"location":"cookbook/subdomains/#conclusion","title":"Conclusion","text":"<p>TON blockchain offers flexible options for subdomain management, whether you prefer a centralized approach with the Subdomain Manager or a decentralized, NFT-based solution with the Subdomain Collection. Both solutions are easy to implement and provide powerful tools to manage your subdomains and DNS records efficiently. This guide provides all the necessary steps to get started and take control of your subdomains on TON.</p>"},{"location":"cookbook/subdomains/#see-also","title":"See also","text":"<ul> <li>TON Subdomains Toolbox</li> <li>Subdomain Manager Contract</li> <li>Subdomain Collection Contract</li> </ul>"},{"location":"guide/getting-testnet-assets/","title":"Getting Testnet Assets","text":"<p>This section explains how to claim testnet assets.</p>"},{"location":"guide/getting-testnet-assets/#ton","title":"TON","text":"TON To get TON, go to the Telegram bot and follow its instructions. Open Telegram Bot"},{"location":"guide/getting-testnet-assets/#not-jetton-9-decimals","title":"NOT Jetton (9 decimals)","text":"NOT Jetton To claim NOT jettons, scan this QR code in your TON wallet. Claim Testnet NOT"},{"location":"guide/getting-testnet-assets/#usd-jetton-6-decimals","title":"USD\u20ae Jetton (6 decimals)","text":"USD\u20ae Jetton To claim USD\u20ae jettons, scan this QR code in your TON wallet. Claim Testnet USD\u20ae"},{"location":"guide/installation-and-initialization/","title":"Installation and Initialization","text":"<p>This section explains how to install the <code>tonutils</code> library and select the appropriate client depending on your needs.</p>"},{"location":"guide/installation-and-initialization/#installation","title":"Installation","text":"<p>To install the base <code>tonutils</code> package:</p> <pre><code>pip install tonutils\n</code></pre> <p>If you need to use Native ADNL connections (for example, via the pytoniq library), install with optional dependencies:</p> <pre><code>pip install 'tonutils[pytoniq]'\n</code></pre>"},{"location":"guide/installation-and-initialization/#available-clients","title":"Available Clients","text":""},{"location":"guide/installation-and-initialization/#rpc-api","title":"RPC API","text":""},{"location":"guide/installation-and-initialization/#toncenter","title":"toncenter","text":"<p>toncenter.com \u2014 fast and reliable HTTP API for The Open Network.  </p> <p>Note</p> <p>API key is optional, but for better performance it is recommended to obtain one via  @tonapibot.</p> <pre><code>from tonutils.client import ToncenterV2Client\nfrom tonutils.client import ToncenterV3Client\n\nAPI_KEY = \"your api key\"  # Optional\nIS_TESTNET = True\n\n# Using Toncenter V3 client\nclient_v3 = ToncenterV3Client(api_key=API_KEY, is_testnet=IS_TESTNET)\n\n# Using Toncenter V2 client (if needed)\n# client_v2 = ToncenterV2Client(api_key=API_KEY, is_testnet=IS_TESTNET)\n</code></pre>"},{"location":"guide/installation-and-initialization/#tonapi","title":"tonapi","text":"<p>tonapi.io \u2014 REST API to the TON blockchain explorer.  </p> <p>Note</p> <p>Requires an API key from tonconsole.com.</p> <pre><code>from tonutils.client import TonapiClient\n\nAPI_KEY = \"your api key\"\nIS_TESTNET = True\nclient = TonapiClient(api_key=API_KEY, is_testnet=IS_TESTNET)\n</code></pre>"},{"location":"guide/installation-and-initialization/#quicknode","title":"quicknode","text":"<p>quicknode.com \u2014 low-latency HTTP API access to TON via global infrastructure.  </p> <p>Note</p> <p>Does not support testnet!</p> <p>Note</p> <p>Requires an API URL from quicknode.com.</p> <pre><code>from tonutils.client import QuicknodeClient\n\nHTTP_PROVIDER_URL = \"https://blissful-withered-surf.ton-mainnet.quiknode.pro/d6e8...1964\"\nclient = QuicknodeClient(HTTP_PROVIDER_URL)\n</code></pre>"},{"location":"guide/installation-and-initialization/#tatum","title":"tatum","text":"<p>tatum.io \u2014 RPCs and APIs powering Web3.  </p> <p>Note</p> <p>Requires an API key from tatum.io.</p> <pre><code>from tonutils.client import TatumClient\n\nAPI_KEY = \"your api key\"\nIS_TESTNET = True\nclient = TatumClient(api_key=API_KEY, is_testnet=IS_TESTNET)\n</code></pre>"},{"location":"guide/installation-and-initialization/#native-adnl","title":"Native ADNL","text":""},{"location":"guide/installation-and-initialization/#pytoniq","title":"pytoniq","text":"<p>pytoniq \u2014 library for direct interaction with Lite servers.  </p> <p>Note</p> <p>For better performance, provide your own config, which can be obtained from the liteserver bot.</p> <pre><code>from tonutils.client import LiteserverClient\n\nIS_TESTNET = True\nclient = LiteserverClient(is_testnet=IS_TESTNET)\n\n# Using custom configuration\n# config = {}  # Your LiteServer config here \n# client = LiteserverClient(config=config)\n</code></pre>"},{"location":"how-to/get-contract-code-and-data/","title":"Get Contract code and data","text":"<p>To retrieve the code and data of a contract, you can use TON explorers such as tonviewer.com, tonscan.org, and others, or use the <code>get_raw_account</code> method programmatically.</p>"},{"location":"how-to/get-contract-code-and-data/#using-ton-explorers","title":"Using TON explorers","text":"<ol> <li>Open Tonviewer.</li> <li>Enter the contract address into the search field.</li> <li>Navigate to the Code tab.</li> <li>The Bytecode section contains the contract code.</li> <li>The Raw data section contains the contract data.</li> </ol>"},{"location":"how-to/get-contract-code-and-data/#using-get_raw_account-method","title":"Using <code>get_raw_account</code> method","text":"<pre><code>from tonutils.client import ToncenterV3Client\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    contract_address = \"EQ...\"\n    account = await client.get_raw_account(contract_address)\n\n    # Print contract code (hex-encoded BOC)\n    print(account.code.to_boc().hex())\n\n    # Print contract data (hex-encoded BOC)\n    print(account.data.to_boc().hex())\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())\n</code></pre> <p>See RawAccount fields overview</p>"},{"location":"how-to/get-contract-information/","title":"Get Contract information","text":"<p>This example shows how to retrieve full contract details, including balance, status, code, data, and last transaction metadata.</p> <pre><code>from tonutils.client import ToncenterV3Client\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    contract_address = \"EQ...\"\n\n    contract = await client.get_raw_account(contract_address)\n\n    print(f\"Balance: {contract.balance}\")\n    print(f\"Status: {contract.status}\")\n    print(f\"Code: {contract.code}\")\n    print(f\"Data: {contract.data}\")\n    print(f\"Last Transaction LT: {contract.last_transaction_lt}\")\n    print(f\"Last Transaction Hash: {contract.last_transaction_hash}\")\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())\n</code></pre>"},{"location":"how-to/get-contract-information/#rawaccount-fields-overview","title":"<code>RawAccount</code> fields overview","text":"<ul> <li> <p>balance \u2192 integer (in nanoTON)   Current balance of the contract.</p> </li> <li> <p>status \u2192 string   Contract status, one of:</p> <ul> <li><code>active</code> \u2192 contract exists and is active</li> <li><code>nonexist</code> \u2192 contract does not exist</li> <li><code>frozen</code> \u2192 contract is frozen</li> <li><code>uninit</code> \u2192 contract exists but is not initialized</li> </ul> </li> <li> <p>code \u2192 <code>Cell</code> (optional)   The contract\u2019s executable code (if present).</p> </li> <li> <p>data \u2192 <code>Cell</code> (optional)   The contract\u2019s persistent data (if present).</p> </li> <li> <p>last_transaction_lt \u2192 integer (optional)   Logical time (LT) of the most recent transaction.</p> </li> <li> <p>last_transaction_hash \u2192 string (optional)   Hash of the most recent transaction.</p> </li> <li> <p>state_init \u2192 <code>StateInit</code> (optional)   Combined object representing the full contract state if both code and data are available.</p> </li> </ul>"},{"location":"how-to/get-jetton-wallet-address/","title":"Get Jetton Wallet address","text":"<p>There are several ways to obtain the address of a Jetton Wallet.</p>"},{"location":"how-to/get-jetton-wallet-address/#standard-jetton","title":"Standard Jetton","text":""},{"location":"how-to/get-jetton-wallet-address/#using-the-get_wallet_address-method","title":"Using the <code>get_wallet_address</code> method","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStandard\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    owner_address = \"UQ...\"\n    jetton_master_address = \"EQ...\"\n\n    wallet_address = await JettonMasterStandard.get_wallet_address(\n        client,\n        owner_address,\n        jetton_master_address,\n    )\n    print(wallet_address.to_str())\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())\n</code></pre>"},{"location":"how-to/get-jetton-wallet-address/#calculating-the-address-locally","title":"Calculating the address locally","text":"<p>Note</p> <p>Prepare the Jetton Wallet contract code by following the instructions in Get Contract code and data.</p> <pre><code>from tonutils.jetton import JettonMasterStandard\n\ndef main() -&gt; None:\n    owner_address = \"UQ...\"\n    jetton_wallet_code = \"...\"\n    jetton_master_address = \"EQ...\"\n\n    wallet_address = JettonMasterStandard.calculate_user_jetton_wallet_address(\n        owner_address,\n        jetton_wallet_code,\n        jetton_master_address,\n    )\n    print(wallet_address.to_str())\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"how-to/get-jetton-wallet-address/#stablecoin-jetton-eg-usd-not","title":"Stablecoin Jetton (e.g., USD\u20ae, NOT)","text":""},{"location":"how-to/get-jetton-wallet-address/#using-the-get_wallet_address-method_1","title":"Using the <code>get_wallet_address</code> method","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.jetton import JettonMasterStablecoin\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    owner_address = \"UQ...\"\n    jetton_master_address = \"EQ...\"\n\n    wallet_address = await JettonMasterStablecoin.get_wallet_address(\n        client,\n        owner_address,\n        jetton_master_address,\n    )\n    print(wallet_address.to_str())\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())\n</code></pre>"},{"location":"how-to/get-jetton-wallet-address/#calculating-the-address-locally_1","title":"Calculating the address locally","text":"<p>Note</p> <p>Prepare the Jetton Wallet contract code by following the instructions in Get Contract code and data.</p> <pre><code>from tonutils.jetton import JettonMasterStablecoin\n\ndef main() -&gt; None:\n    owner_address = \"UQ...\"\n    jetton_wallet_code = \"...\"\n    jetton_master_address = \"EQ...\"\n\n    wallet_address = JettonMasterStablecoin.calculate_user_jetton_wallet_address(\n        owner_address,\n        jetton_wallet_code,\n        jetton_master_address,\n    )\n    print(wallet_address.to_str())\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"how-to/get-nft-item-address/","title":"Get NFT Item address","text":"<p>There are several ways to obtain the address of an NFT Item.</p>"},{"location":"how-to/get-nft-item-address/#standard-collections","title":"Standard collections","text":""},{"location":"how-to/get-nft-item-address/#using-the-get_nft_address_by_index-get-method","title":"Using the <code>get_nft_address_by_index</code> get-method","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.nft import Collection\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    nft_index = 1\n    collection_address = \"EQ...\"\n\n    nft_address = await Collection.get_nft_address_by_index(\n        client,\n        nft_index,\n        collection_address,\n    )\n    print(nft_address.to_str())\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())\n</code></pre>"},{"location":"how-to/get-nft-item-address/#calculating-the-address-locally","title":"Calculating the address locally","text":"<p>Note</p> <p>Prepare the NFT Item contract code by following the instructions in Get Contract code and data.</p> <pre><code>from tonutils.nft import Collection\n\ndef main() -&gt; None:\n    nft_index = 1\n    nft_item_code = \"...\"\n    collection_address = \"EQ...\"\n\n    nft_address = Collection.calculate_nft_item_address(\n        nft_index,\n        nft_item_code,\n        collection_address,\n    )\n    print(nft_address.to_str())\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"how-to/get-nft-item-address/#ton-dns-domains-collection","title":"TON DNS Domains collection","text":"<p>Note</p> <p>The index is computed as <code>slice_hash(name)</code>. See Use FunC hash functions for details.</p>"},{"location":"how-to/get-nft-item-address/#using-the-get_nft_address_by_index-get-method_1","title":"Using the <code>get_nft_address_by_index</code> get-method","text":"<pre><code>from pytoniq_core import begin_cell\nfrom tonutils.client import ToncenterV3Client\nfrom tonutils.nft import Collection\nfrom tonutils.utils import slice_hash\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    domain_name = \"temp\"\n    domain_index = slice_hash(begin_cell().store_string(domain_name))[1]\n    collection_address = \"EQC3dNlesgVD8YbAazcauIrXBPfiVhMMr5YYk2in0Mtsz0Bz\"\n\n    nft_address = await Collection.get_nft_address_by_index(\n        client,\n        domain_index,\n        collection_address,\n    )\n    print(nft_address.to_str())\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())\n</code></pre>"},{"location":"how-to/get-nft-item-address/#telegram-gifts-anonymous-telegram-numbers","title":"Telegram Gifts / Anonymous Telegram Numbers","text":"<p>Note</p> <p>The index is computed as <code>string_hash(telemint_token_name)</code>. See Use FunC hash functions for details.</p>"},{"location":"how-to/get-nft-item-address/#using-the-get_nft_address_by_index-get-method_2","title":"Using the <code>get_nft_address_by_index</code> get-method","text":"<pre><code>from tonutils.client import ToncenterV3Client\nfrom tonutils.nft import Collection\nfrom tonutils.utils import string_hash\n\nasync def main() -&gt; None:\n    client = ToncenterV3Client()\n    token_name = \"8888888\"\n    token_index = string_hash(token_name)[1]\n    collection_address = \"EQAOQdwdw8kGftJCSFgOErM1mBjYPe4DBPq8-AhF6vr9si5N\"\n\n    nft_address = await Collection.get_nft_address_by_index(\n        client,\n        token_index,\n        collection_address,\n    )\n    print(nft_address.to_str())\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())\n</code></pre>"},{"location":"how-to/use-func-hash-functions/","title":"Use FunC hash functions","text":""},{"location":"how-to/use-func-hash-functions/#cell_hash","title":"cell_hash","text":"<p>Calculates the representation hash of the given cell c and returns it as a 256-bit unsigned integer x. This function is handy for signing and verifying signatures of arbitrary entities structured as a tree of cells.</p> <pre><code>from tonutils.utils import cell_hash\nfrom pytoniq_core import begin_cell\n\ndef main() -&gt; None:\n    c = begin_cell().store_string(\"ness\").end_cell()\n    cell_hash_result = cell_hash(c)\n    print(f\"bytes: {cell_hash_result[0]}\")\n    print(f\"int: {cell_hash_result[1]}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"how-to/use-func-hash-functions/#slice_hash","title":"slice_hash","text":"<p>Computes the hash of the given slice s and returns it as a 256-bit unsigned integer x. The result is equivalent to creating a standard cell containing only the data and references from s and then computing its hash using cell_hash.</p> <pre><code>from tonutils.utils import slice_hash\nfrom pytoniq_core import begin_cell\n\ndef main() -&gt; None:\n    s = begin_cell().store_string(\"ness\")\n    slice_hash_result = slice_hash(s)\n    print(f\"bytes: {slice_hash_result[0]}\")\n    print(f\"int: {slice_hash_result[1]}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"how-to/use-func-hash-functions/#string_hash","title":"string_hash","text":"<p>Calculates the SHA-256 hash of the data bits in the given slice s. A cell underflow exception is thrown if the bit length of s is not a multiple of eight. The hash is returned as a 256-bit unsigned integer x.</p> <pre><code>from tonutils.utils import string_hash\n\ndef main() -&gt; None:\n    string_hash_result = string_hash(\"ness\")\n    print(f\"bytes: {string_hash_result[0]}\")\n    print(f\"int: {string_hash_result[1]}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"}]}